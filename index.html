<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>勇者のクイズ冒険</title>
    <!-- ドット絵風の日本語フォントを読み込む -->
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    <style>
        /* --- 変数定義 (色設定) --- */
        :root {
            --bg-color: #000; /* 背景色（黒） */
            --text-color: #fff; /* 文字色（白） */
            --border-color: #fff; /* 枠線色（白） */
            --accent-color: #f8b500; /* 強調色（黄色、ドラクエ風） */
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            color: var(--text-color);
            /* ゲーム全体にドット絵風フォントを適用 */
            font-family: 'DotGothic16', sans-serif;
            overflow: hidden; /* スクロールを禁止 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            height: 100dvh; /* 動的ビューポートに対応 */
            touch-action: none; /* タッチデバイスでのピンチズームなどを無効化 */
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px; /* PCでも大きくなりすぎないように制限 */
            /* 画面内に収めるための制約を追加 */
            max-height: calc(100dvh - 30px); /* ツールバーやセーフエリアを考慮して少し余裕を持たせる */
            aspect-ratio: 3/4; /* 縦横比を固定 */
            background-color: var(--bg-color);
            border: 2px solid #444;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            overflow: hidden;
            margin: auto; /* 中央配置 */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* ドット絵のようにクッキリ表示させる設定 */
        }

        /* --- UI Overlay (メッセージボックス & ステータス) --- */
        .ui-box {
            position: absolute;
            background: #000;
            border: 4px double var(--border-color); /* 昔ながらの二重線枠 */
            border-radius: 4px;
            padding: 10px;
            box-sizing: border-box;
            display: none; /* デフォルトは非表示にしてJavaScriptで表示制御 */
        }

        #message-window {
            bottom: 165px; /* 仮想コントローラーの上に配置 */
            left: 5%;
            width: 90%;
            height: 120px;
            font-size: 18px;
            line-height: 1.6;
            z-index: 10;
        }

        #choice-window {
            top: 20px;
            right: 20px;
            width: 200px;
            z-index: 11;
        }

        .choice-item {
            padding: 5px 10px;
            cursor: pointer;
            list-style: none; /* リストのデフォルトの点を消す */
            transition: background-color 0.1s;
        }
        
        /* マウスオーバー/タップ時のフィードバック */
        .choice-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .choice-item.selected {
            background-color: rgba(255, 255, 255, 0.2); /* 選択中の背景色 */
        }

        .choice-item.selected::before {
            content: '▶'; /* 選択中の行にカーソル（矢印）を表示 */
            margin-right: 5px;
            color: var(--accent-color);
        }
        
        /* 選択されていないときはカーソル非表示 */
        .choice-item:not(.selected)::before {
            content: ' '; 
            margin-right: 5px;
        }

        .cursor-indicator {
            /* テキスト入力完了後に表示される点滅カーソル */
            animation: blink 0.8s infinite;
            display: inline-block;
            margin-left: 5px;
            width: 10px;
            height: 10px;
            background-color: #fff;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* --- 仮想コントローラー (モバイル操作用) --- */
        #controls {
            position: absolute;
            bottom: 15px; /* 画面下端から少し浮かせる */
            left: 0;
            width: 100%;
            height: 140px;
            pointer-events: none; /* デフォルトで透過させ、ボタン部分のみ反応させる */
            display: flex;
            justify-content: space-between; /* 左右に分けて配置 */
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 20;
        }

        .d-pad {
            /* 十字キー全体 */
            position: relative;
            width: 120px;
            height: 120px;
            pointer-events: auto; /* クリック/タッチを有効化 */
        }

        .d-btn {
            /* 各方向ボタンのスタイル */
            position: absolute;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 5px;
        }
        .d-btn:active { background: rgba(255, 255, 255, 0.5); } /* 押された時の色 */

        /* 各方向ボタンの位置指定 */
        .d-up { top: 0; left: 40px; width: 40px; height: 40px; }
        .d-down { bottom: 0; left: 40px; width: 40px; height: 40px; }
        .d-left { top: 40px; left: 0; width: 40px; height: 40px; }
        .d-right { top: 40px; right: 0; width: 40px; height: 40px; }

        .action-pad {
            /* A/Bボタンのコンテナ */
            pointer-events: auto;
            display: flex;
            gap: 15px;
        }

        .action-btn {
            /* A/Bボタンの共通スタイル */
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: white;
            font-family: 'DotGothic16', sans-serif;
            font-size: 14px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }
        .action-btn:active { background: rgba(200, 50, 50, 0.7); }
        .btn-a { background: rgba(200, 50, 50, 0.4); } /* Aボタン (決定) */
        .btn-b { background: rgba(50, 50, 200, 0.4); } /* Bボタン (キャンセル/未実装) */

    </style>
</head>
<body>

<div id="game-container">
    <!-- ゲーム画面を描画するキャンバス要素 -->
    <canvas id="gameCanvas"></canvas>

    <!-- メッセージ表示ウィンドウ -->
    <div id="message-window" class="ui-box">
        <div id="message-text"></div>
        <div id="message-cursor" class="cursor-indicator" style="display:none;"></div>
    </div>

    <!-- 選択肢ウィンドウ -->
    <div id="choice-window" class="ui-box">
        <div id="choices-list"></div>
    </div>

    <!-- 仮想コントローラー -->
    <div id="controls">
        <div class="d-pad">
            <div class="d-btn d-up" data-key="ArrowUp"></div>
            <div class="d-btn d-down" data-key="ArrowDown"></div>
            <div class="d-btn d-left" data-key="ArrowLeft"></div>
            <div class="d-btn d-right" data-key="ArrowRight"></div>
        </div>
        <div class="action-pad">
            <div class="action-btn btn-b" data-key="Cancel">B</div>
            <div class="action-btn btn-a" data-key="Enter">A</div>
        </div>
    </div>
</div>

<script>
    // --- 定数と設定 ---
    const TILE_SIZE = 32;       // 1タイルの大きさ（ピクセル）
    const VIEW_WIDTH = 15;      // 画面に表示するタイル数（横）
    const VIEW_HEIGHT = 15;     // 画面に表示するタイル数（縦）

    const COLOR_GRASS = '#4caf50';
    const COLOR_TREE = '#1b5e20';
    const COLOR_WATER = '#0288d1';
    const COLOR_WALL = '#795548';
    const COLOR_FLOOR = '#3e2723';
    
    const SPRITE_HERO = { color: '#2196f3', type: 'hero' };
    const SPRITE_NPC_GUARD = { color: '#f44336', type: 'guard' };
    const SPRITE_NPC_KING = { color: '#ffeb3b', type: 'king' };
    const SPRITE_NPC_VILLAGER = { color: '#8bc34a', type: 'villager' };
    const SPRITE_NPC_SOLDIER = { color: '#9e9e9e', type: 'soldier' };

    const STATE = {
        EXPLORING: 0,
        DIALOGUE: 1,
        CHOICE: 2,
        ANIMATING: 3
    };

    let currentState = STATE.EXPLORING;
    const deepClone = (obj) => JSON.parse(JSON.stringify(obj));

    const MAP_DATA = [
        {
            id: 0,
            name: "村外れの野原",
            playerStart: { x: 2, y: 2 },
            layout: [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,1,0,0,0,0,0,1,9,9,9,9,9,9,1],
                [1,0,0,1,1,0,1,0,0,0,0,0,1,9,0,0,0,0,9,1],
                [1,0,0,1,1,0,0,0,0,0,0,0,4,9,0,0,0,0,9,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,3,9,0,0,0,0,9,1],
                [1,0,0,0,0,2,2,2,0,0,0,0,4,9,0,0,0,0,9,1],
                [1,1,0,0,0,2,2,2,2,0,0,0,1,9,9,9,9,9,9,1],
                [1,1,1,0,0,0,2,2,0,0,0,0,1,1,1,1,4,1,1,1],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: [
                {
                    x: 5, y: 5, name: '村人', sprite: SPRITE_NPC_VILLAGER,
                    dialogue: ["この先に進めば王様の城だが、", "最初の門番がクイズを出してくるぞ。"],
                    blocking: true
                },
                {
                    x: 12, y: 5, name: '門番', sprite: SPRITE_NPC_GUARD,
                    dialogue: ["止まれ！", "ここを通したければ、私のクイズに答えてみよ。"],
                    blocking: true, 
                    quiz: {
                        question: "パンはパンでも、\n食べられないパンはなーんだ？",
                        options: ["フライパン", "食パン", "ジャパン"],
                        correct: 0,
                        onCorrect: (npc) => {
                            displayText("「正解だ！城の庭へ通るがよい。」", () => {
                                npc.quiz = null; 
                                changeMap(1); 
                            });
                        },
                        onWrong: () => {
                            displayText("「違うな。出直してこい！」", () => {
                                pushPlayerBack();
                            });
                        }
                    }
                },
            ]
        },
        {
            id: 1,
            name: "城の庭",
            playerStart: { x: 5, y: 15 },
            layout: [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1],
                [1,4,3,2,2,3,3,2,2,3,3,2,2,3,3,2,2,3,4,1],
                [1,4,3,2,2,3,3,2,2,3,3,2,2,3,3,2,2,3,4,1],
                [1,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1],
                [1,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1],
                [1,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1],
                [1,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1],
                [1,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1],
                [1,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1],
                [1,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1],
                [1,4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,1],
                [1,1,1,1,1,1,1,1,1,9,9,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,9,9,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,9,9,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,9,9,1,1,1,1,1,1,1,1,1],
            ],
            entities: [
                {
                    x: 10, y: 4, name: '兵士', sprite: SPRITE_NPC_SOLDIER,
                    dialogue: ["私は王様の近衛兵だ。", "謁見の間に入るには、\n私の出す難問を解いてもらおう。"],
                    blocking: true, 
                    quiz: {
                        question: "Webページを作るために必須の言語は？",
                        options: ["Python", "HTML", "C++"],
                        correct: 1,
                        onCorrect: (npc) => {
                            displayText("「見事！城の奥へ進むが良い。」", () => {
                                npc.quiz = null;
                                changeMap(2);
                            });
                        },
                        onWrong: () => {
                            displayText("「残念。鍛錬を積んで出直せ！」", () => {
                                pushPlayerBack();
                            });
                        }
                    }
                },
                {
                    x: 4, y: 10, name: '庭師', sprite: SPRITE_NPC_VILLAGER,
                    dialogue: ["最近、水やりが大変でね。", "水場が多いだろう？"],
                    blocking: true
                },
            ]
        },
        {
            id: 2,
            name: "謁見の間",
            playerStart: { x: 9, y: 14 },
            layout: [
                [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4],
                [1,1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: [
                {
                    x: 9, y: 3, name: '王様', sprite: SPRITE_NPC_KING,
                    dialogue: ["よくぞ参った勇者よ！", "最後に、私からの究極のクイズに答えるのだ！"],
                    blocking: true,
                    quiz: {
                        question: "プログラミングで「もし～なら」\nという条件分岐に使うのは？",
                        options: ["loop", "if", "var"],
                        correct: 1,
                        onCorrect: (npc) => {
                            displayText("「見事だ！\nお主こそ真のプログラマーじゃ！」", () => {
                                npc.dialogue = ["世界は平和になった。"];
                                npc.quiz = null;
                                createConfetti();
                            });
                        },
                        onWrong: () => {
                            displayText("「勉強不足じゃな。」");
                        }
                    }
                }
            ]
        }
    ];

    let currentMapId = 0;
    let currentMap = MAP_DATA[currentMapId];
    let entities = deepClone(currentMap.entities);
    let player = {
        x: currentMap.playerStart.x,
        y: currentMap.playerStart.y,
        direction: 'down',
        stepState: 0
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const messageWindow = document.getElementById('message-window');
    const messageText = document.getElementById('message-text');
    const messageCursor = document.getElementById('message-cursor');
    const choiceWindow = document.getElementById('choice-window');
    const choicesList = document.getElementById('choices-list');

    let currentChoiceIndex = -1; 

    function resize() {
        const container = document.getElementById('game-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        ctx.imageSmoothingEnabled = false;
    }
    window.addEventListener('resize', resize);
    resize();

    const keys = {};
    let lastKeyTime = 0;
    const keyRepeatRate = 150;

    let currentQuizData = null;
    let textAnimationTimer = null;
    let fullText = "";
    let isWaitingForEnter = false;
    let textCallback = null;

    window.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        handleInput(e.code);
    });
    window.addEventListener('keyup', (e) => {
        keys[e.code] = false;
    });

    document.querySelectorAll('[data-key]').forEach(el => {
        el.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const key = el.getAttribute('data-key');
            keys[key] = true;
            handleInput(key);
        }, {passive: false});
        el.addEventListener('touchend', (e) => {
            e.preventDefault();
            const key = el.getAttribute('data-key');
            keys[key] = false;
        });
        el.addEventListener('mousedown', (e) => {
            const key = el.getAttribute('data-key');
            keys[key] = true;
            handleInput(key);
        });
        el.addEventListener('mouseup', (e) => {
            const key = el.getAttribute('data-key');
            keys[key] = false;
        });
    });

    function handleInput(code) {
        if (STATE.EXPLORING === currentState) {
            handleExplorationInput(code);
        } else if (STATE.DIALOGUE === currentState) {
            handleDialogueInput(code);
        } else if (STATE.CHOICE === currentState) {
            handleChoiceInput(code);
        }
    }

    function handleExplorationInput(code) {
        if (code === 'Enter' || code === 'Space' || code === 'KeyZ') {
            checkInteraction();
        }
    }

    function handleDialogueInput(code) {
        if (code === 'Enter' || code === 'Space' || code === 'KeyZ') {
            if (isWaitingForEnter) {
                if (textCallback) {
                    const cb = textCallback;
                    textCallback = null;
                    cb();
                } else {
                    closeDialogue();
                }
            } else {
                if (textAnimationTimer) {
                    clearInterval(textAnimationTimer);
                    messageText.innerHTML = fullText.replace(/\n/g, '<br>');
                    isWaitingForEnter = true;
                    messageCursor.style.display = 'inline-block';
                }
            }
        }
    }

    function handleChoiceInput(code) {
        if (code === 'ArrowUp') {
            if (currentChoiceIndex === -1) {
                currentChoiceIndex = currentQuizData.options.length - 1;
            } else {
                currentChoiceIndex = Math.max(0, currentChoiceIndex - 1);
            }
            renderChoices();
        } else if (code === 'ArrowDown') {
            if (currentChoiceIndex === -1) {
                currentChoiceIndex = 0;
            } else {
                currentChoiceIndex = Math.min(currentQuizData.options.length - 1, currentChoiceIndex + 1);
            }
            renderChoices();
        } 
        else if (code === 'Enter' || code === 'Space' || code === 'KeyZ') {
            if (currentChoiceIndex !== -1) {
                confirmChoice();
            }
        }
    }

    function isWalkable(x, y) {
        const mapLayout = currentMap.layout;
        if (y < 0 || y >= mapLayout.length || x < 0 || x >= mapLayout[0].length) return false;
        const tile = mapLayout[y][x];
        if (tile === 1 || tile === 2 || tile === 4) return false;
        for (let e of entities) {
            if (e.x === x && e.y === y && e.blocking) return false;
        }
        return true;
    }

    function changeMap(newMapId) {
        if (newMapId >= 0 && newMapId < MAP_DATA.length) {
            currentMapId = newMapId;
            currentMap = MAP_DATA[currentMapId];
            player.x = currentMap.playerStart.x;
            player.y = currentMap.playerStart.y;
            entities = deepClone(currentMap.entities); 
            player.direction = 'down';
            closeDialogue();
            displayText(`マップ移動：${currentMap.name}に到着した...`);
        }
    }

    function update() {
        if (currentState === STATE.EXPLORING) {
            movePlayer();
        }
    }

    function movePlayer() {
        const now = Date.now();
        if (now - lastKeyTime < keyRepeatRate) return;
        let dx = 0, dy = 0, moved = false;
        if (keys['ArrowUp']) { dy = -1; player.direction = 'up'; moved = true; }
        else if (keys['ArrowDown']) { dy = 1; player.direction = 'down'; moved = true; }
        else if (keys['ArrowLeft']) { dx = -1; player.direction = 'left'; moved = true; }
        else if (keys['ArrowRight']) { dx = 1; player.direction = 'right'; moved = true; }
        if (moved) {
            const newX = player.x + dx;
            const newY = player.y + dy;
            if (isWalkable(newX, newY)) {
                player.x = newX;
                player.y = newY;
                player.stepState = (player.stepState + 1) % 2;
            }
            lastKeyTime = now;
        }
    }

    function checkInteraction() {
        let targetX = player.x;
        let targetY = player.y;
        if (player.direction === 'up') targetY--;
        if (player.direction === 'down') targetY++;
        if (player.direction === 'left') targetX--;
        if (player.direction === 'right') targetX++;
        const targetEntity = entities.find(e => e.x === targetX && e.y === targetY);
        if (targetEntity) {
            startDialogueSequence(targetEntity);
        }
    }

    function startDialogueSequence(entity) {
        let msgIndex = 0;
        function showNext() {
            if (msgIndex < entity.dialogue.length) {
                displayText(entity.dialogue[msgIndex], () => {
                    msgIndex++;
                    showNext();
                });
            } else {
                if (entity.quiz) {
                    startQuiz(entity, entity.quiz);
                } else {
                    closeDialogue();
                }
            }
        }
        showNext();
    }

    function displayText(text, callback = null) {
        currentState = STATE.DIALOGUE;
        messageWindow.style.display = 'block';
        messageText.innerHTML = '';
        messageCursor.style.display = 'none';
        fullText = text;
        textCallback = callback;
        isWaitingForEnter = false;
        let i = 0;
        if (textAnimationTimer) clearInterval(textAnimationTimer);
        textAnimationTimer = setInterval(() => {
            messageText.innerHTML = fullText.substring(0, i + 1).replace(/\n/g, '<br>');
            i++;
            if (i >= fullText.length) {
                clearInterval(textAnimationTimer);
                isWaitingForEnter = true;
                messageCursor.style.display = 'inline-block';
            }
        }, 30);
    }

    function closeDialogue() {
        messageWindow.style.display = 'none';
        choiceWindow.style.display = 'none';
        currentState = STATE.EXPLORING;
        textCallback = null;
    }

    function pushPlayerBack() {
        let dx = 0, dy = 0;
        if (player.direction === 'up') dy = 1;
        if (player.direction === 'down') dy = -1;
        if (player.direction === 'left') dx = 1;
        if (player.direction === 'right') dx = -1;
        if (isWalkable(player.x + dx, player.y + dy)) {
            player.x += dx;
            player.y += dy;
        }
        closeDialogue();
    }

    function startQuiz(entity, quizData) {
        currentState = STATE.CHOICE;
        currentQuizData = quizData;
        currentQuizData.entityRef = entity;
        currentChoiceIndex = -1; 
        displayText(quizData.question, () => {
            choiceWindow.style.display = 'block';
            currentChoiceIndex = 0;
            renderChoices();
        });
    }

    function renderChoices() {
        choicesList.innerHTML = '';
        currentQuizData.options.forEach((opt, index) => {
            const li = document.createElement('li');
            li.className = 'choice-item ' + (index === currentChoiceIndex ? 'selected' : '');
            li.textContent = opt;
            li.onclick = () => {
                currentChoiceIndex = index; 
                renderChoices(); 
                confirmChoice();
            };
            li.onmouseover = () => {
                if (currentState === STATE.CHOICE) {
                    currentChoiceIndex = index;
                    renderChoices(); 
                }
            }
            choicesList.appendChild(li);
        });
    }

    function confirmChoice() {
        if (currentChoiceIndex === -1) return;
        choiceWindow.style.display = 'none';
        if (currentChoiceIndex === currentQuizData.correct) {
            if (currentQuizData.onCorrect) {
                currentQuizData.onCorrect(currentQuizData.entityRef);
            } else {
                closeDialogue();
            }
        } else {
            if (currentQuizData.onWrong) {
                currentQuizData.onWrong(currentQuizData.entityRef);
            } else {
                closeDialogue();
            }
        }
        currentChoiceIndex = -1;
    }

    function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const scale = canvas.width / (VIEW_WIDTH * TILE_SIZE);
        ctx.save();
        ctx.scale(scale, scale);
        const camX = player.x * TILE_SIZE - (VIEW_WIDTH * TILE_SIZE) / 2 + TILE_SIZE / 2;
        const camY = player.y * TILE_SIZE - (VIEW_HEIGHT * TILE_SIZE) / 2 + TILE_SIZE / 2;
        ctx.translate(-camX, -camY);
        const mapLayout = currentMap.layout;
        for (let y = 0; y < mapLayout.length; y++) {
            for (let x = 0; x < mapLayout[y].length; x++) {
                drawTile(x, y, mapLayout[y][x]);
            }
        }
        entities.forEach(ent => {
            drawSprite(ent.x, ent.y, ent.sprite);
        });
        drawSprite(player.x, player.y, SPRITE_HERO, true);
        ctx.restore();
        requestAnimationFrame(draw);
    }

    function drawTile(x, y, type) {
        const px = x * TILE_SIZE;
        const py = y * TILE_SIZE;
        let color = '#000';
        switch (type) {
            case 0: color = COLOR_GRASS; break;
            case 1: color = COLOR_TREE; break;
            case 2: color = COLOR_WATER; break;
            case 3: 
            case 9: color = COLOR_FLOOR; break;
            case 4: color = COLOR_WALL; break;
        }
        ctx.fillStyle = color;
        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
        if (type === 1) {
            ctx.fillStyle = '#2e7d32';
            ctx.fillRect(px + 8, py + 8, 16, 16);
        } else if (type === 4) {
            ctx.strokeStyle = '#5d4037';
            ctx.strokeRect(px+2, py+2, TILE_SIZE-4, TILE_SIZE-4);
        } else if (type === 2) {
            if (Date.now() % 1000 < 500) {
                ctx.fillStyle = '#4fc3f7';
                ctx.fillRect(px + 5, py + 5, 5, 2);
            }
        }
    }

    function drawSprite(gridX, gridY, sprite, isPlayer = false) {
        const px = gridX * TILE_SIZE;
        const py = gridY * TILE_SIZE;
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(px + 16, py + 26, 10, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        let offset = 0;
        if (isPlayer && (keys['ArrowUp'] || keys['ArrowDown'] || keys['ArrowLeft'] || keys['ArrowRight'])) {
             offset = (Date.now() % 200 < 100) ? -2 : 0;
        }
        ctx.fillStyle = sprite.color;
        ctx.fillRect(px + 8, py + 4 + offset, 16, 14);
        ctx.fillStyle = '#000';
        ctx.fillRect(px + 8, py + 18 + offset, 6, 8);
        ctx.fillRect(px + 18, py + 18 + offset, 6, 8);
        ctx.fillStyle = '#fff';
        ctx.fillRect(px + 10, py + 8 + offset, 4, 4);
        ctx.fillRect(px + 18, py + 8 + offset, 4, 4);
        ctx.fillStyle = '#000';
        if (isPlayer) {
             let eyeOffsetX = 1;
             if (player.direction === 'left') eyeOffsetX = 0;
             if (player.direction === 'right') eyeOffsetX = 2;
             ctx.fillRect(px + 10 + eyeOffsetX, py + 9 + offset, 2, 2);
             ctx.fillRect(px + 18 + eyeOffsetX, py + 9 + offset, 2, 2);
        } else {
             ctx.fillRect(px + 11, py + 9 + offset, 2, 2);
             ctx.fillRect(px + 19, py + 9 + offset, 2, 2);
        }
        if (sprite.type === 'king') {
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(px + 8, py + offset, 16, 4);
            ctx.fillStyle = '#f00';
            ctx.fillRect(px + 6, py + 16 + offset, 20, 10);
        }
        else if (sprite.type === 'guard') {
            ctx.fillStyle = '#607d8b';
            ctx.fillRect(px + 6, py + 2 + offset, 20, 4);
        }
        else if (sprite.type === 'soldier') {
            ctx.fillStyle = '#263238';
            ctx.fillRect(px + 7, py + 6 + offset, 18, 18);
        }
    }

    function createConfetti() {
        for(let i=0; i<50; i++) {
            setTimeout(() => {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 5 + 2;
                const color = `hsl(${Math.random()*360}, 100%, 50%)`;
                const oldFill = ctx.fillStyle;
                ctx.fillStyle = color;
                ctx.fillRect(x, y, size, size);
                ctx.fillStyle = oldFill;
            }, i * 20);
        }
    }

    setInterval(update, 1000 / 60);
    requestAnimationFrame(draw);
    setTimeout(() => {
        displayText(`勇者よ、${currentMap.name}で目覚めた。\n城へ向かい、王様に会うのだ。`);
    }, 500);
</script>
</body>
</html>