<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>勇者のクイズ冒険</title>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #000;
            --text-color: #fff;
            --border-color: #fff;
            --accent-color: #f8b500;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            color: var(--text-color);
            font-family: 'DotGothic16', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            max-height: calc(100dvh - 30px);
            aspect-ratio: 3/4;
            background-color: var(--bg-color);
            border: 2px solid #444;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            overflow: hidden;
            margin: auto;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .ui-box {
            position: absolute;
            background: #000;
            border: 4px double var(--border-color);
            border-radius: 4px;
            padding: 10px;
            box-sizing: border-box;
            display: none;
        }

        /* --- タイトル画面（フロア選択） --- */
        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #title-message {
            font-size: 16px;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        #level-list {
            list-style: none;
            padding: 0;
            margin: 0;
            width: 100%;
            max-width: 300px;
            max-height: 60vh;
            overflow-y: auto;
            border: 2px solid #444;
        }

        .level-item {
            padding: 12px;
            cursor: pointer;
            border-bottom: 1px solid #333;
            transition: background 0.2s;
        }

        .level-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .level-item.selected {
            background-color: rgba(248, 181, 0, 0.3);
            border-left: 4px solid var(--accent-color);
            padding-left: 8px;
        }
        
        .level-item.selected::before {
            content: '▶ ';
            color: var(--accent-color);
        }

        #message-window {
            bottom: 160px;
            left: 5%;
            width: 90%;
            min-height: 120px;
            font-size: 18px;
            line-height: 1.6;
            z-index: 10;
            padding-bottom: 40px;
        }

        #message-ok-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(200, 50, 50, 0.8);
            border: 2px solid #fff;
            border-radius: 4px;
            padding: 6px 16px;
            color: #fff;
            font-family: 'DotGothic16', sans-serif;
            font-size: 14px;
            cursor: pointer;
            user-select: none;
            display: none;
        }
        #message-ok-btn:active {
            background: rgba(255, 80, 80, 1);
        }

        #quiz-window {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 400px;
            max-height: 85vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 15;
            padding: 20px;
            padding-bottom: 50px;
            display: none;
            flex-direction: column;
        }

        #quiz-question {
            font-size: 18px;
            margin-bottom: 15px;
            line-height: 1.5;
            white-space: pre-wrap;
            max-height: 50vh;
            overflow-y: auto;
            touch-action: pan-y;
            padding-right: 8px;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color) #333;
        }

        #quiz-question::-webkit-scrollbar { width: 6px; }
        #quiz-question::-webkit-scrollbar-track { background: #222; }
        #quiz-question::-webkit-scrollbar-thumb { background-color: var(--accent-color); border-radius: 3px; }

        #quiz-choices {
            list-style: none;
            padding: 0;
            margin: 0;
            margin-bottom: 10px;
            overflow-y: auto;
            max-height: 30vh;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color) #333;
        }

        #quiz-choices::-webkit-scrollbar { width: 6px; }
        #quiz-choices::-webkit-scrollbar-track { background: #222; }
        #quiz-choices::-webkit-scrollbar-thumb { background-color: var(--accent-color); border-radius: 3px; }

        .choice-item {
            padding: 10px;
            cursor: pointer;
            list-style: none;
            transition: background-color 0.1s;
            margin-bottom: 5px;
            border: 2px solid transparent;
        }
        
        .choice-item:hover { background-color: rgba(255, 255, 255, 0.1); }
        .choice-item.selected { background-color: rgba(255, 255, 255, 0.2); border-color: var(--accent-color); }
        .choice-item.selected::before { content: '▶'; margin-right: 5px; color: var(--accent-color); }
        .choice-item:not(.selected)::before { content: ' '; margin-right: 5px; }
        
        .choice-item.hint-btn { color: #81d4fa; border-top: 1px dashed #555; margin-top: 10px; }

        #quiz-ok-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(200, 50, 50, 0.8);
            border: 2px solid #fff;
            border-radius: 4px;
            padding: 6px 16px;
            color: #fff;
            font-family: 'DotGothic16', sans-serif;
            font-size: 14px;
            cursor: pointer;
            user-select: none;
            display: none;
        }
        #quiz-ok-btn:active { background: rgba(255, 80, 80, 1); }

        .cursor-indicator {
            animation: blink 0.8s infinite;
            display: inline-block;
            margin-left: 5px;
            width: 10px;
            height: 10px;
            background-color: #fff;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* --- 仮想コントローラー (モバイル操作用) --- */
        #controls {
            position: absolute;
            bottom: 15px;
            left: 0;
            width: 100%;
            height: 140px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 20;
        }

        .d-pad {
            position: relative;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }

        .d-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 5px;
        }
        .d-btn:active { background: rgba(255, 255, 255, 0.5); }

        .d-up { top: 0; left: 40px; width: 40px; height: 40px; }
        .d-down { bottom: 0; left: 40px; width: 40px; height: 40px; }
        .d-left { top: 40px; left: 0; width: 40px; height: 40px; }
        .d-right { top: 40px; right: 0; width: 40px; height: 40px; }

        .action-pad {
            pointer-events: auto;
            display: flex;
            gap: 15px;
        }

        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: #fff;
            font-family: 'DotGothic16', sans-serif;
        }

        #loading-message {
            margin-top: 10px;
            font-size: 16px;
            text-align: center;
            white-space: pre-wrap;
        } 
        
        /* --- メニューボタン --- */
        #menu-btn {
            position: absolute;
            bottom: 15px; /* 右下隅 */
            right: 15px;
            background: rgba(50, 50, 200, 0.8);
            border: 2px solid #fff;
            border-radius: 4px;
            padding: 8px 12px;
            color: #fff;
            font-family: 'DotGothic16', sans-serif;
            font-size: 14px;
            cursor: pointer;
            z-index: 30; /* コントローラーより上 */
            user-select: none;
            display: none; /* 初期は非表示 */
        }
        #menu-btn:hover { background: rgba(80, 80, 220, 0.9); }
        #menu-btn:active { background: rgba(100, 100, 255, 1); }

    </style>
</head>
<body>

<div id="game-container">
    <div id="loading-screen">
        <h2 style="margin-top:0;">LOADING...</h2>
        <div id="loading-message">準備中...</div>
    </div>
    
    <!-- タイトル画面 / レベル選択 -->
    <div id="title-screen" style="display:none;">
        <h2 style="color:var(--accent-color); font-size: 24px;">言文クエスト</h2>
        <div id="title-message">攻略するフロアを選んでください。<br>（★:クリア済 / 数字:残り敵数）</div>
        <ul id="level-list">
            <!-- JSで生成 -->
        </ul>
    </div>

    <canvas id="gameCanvas"></canvas>
    
    <!-- メニューボタン -->
    <div id="menu-btn">メニューへ</div>

    <div id="message-window" class="ui-box">
        <div id="message-text"></div>
        <div id="message-cursor" class="cursor-indicator" style="display:none;"></div>
        <div id="message-ok-btn">OK</div>
    </div>

    <div id="quiz-window" class="ui-box">
        <div id="quiz-question"></div>
        <ul id="quiz-choices"></ul>
        <div id="quiz-ok-btn">OK</div>
    </div>

    <div id="controls">
        <div class="d-pad">
            <div class="d-btn d-up" data-key="ArrowUp"></div>
            <div class="d-btn d-down" data-key="ArrowDown"></div>
            <div class="d-btn d-left" data-key="ArrowLeft"></div>
            <div class="d-btn d-right" data-key="ArrowRight"></div>
        </div>
        <div class="action-pad">
            <!-- ボタンなし -->
        </div>
    </div>
</div>

<script>
    const TILE_SIZE = 32;
    const VIEW_WIDTH = 15;
    const VIEW_HEIGHT = 15;

    const COLOR_GRASS = '#4caf50';
    const COLOR_TREE = '#1b5e20';
    const COLOR_WATER = '#0288d1';
    const COLOR_WALL = '#795548';
    const COLOR_FLOOR = '#3e2723';
    
    const SPRITE_HERO = { color: '#2196f3', type: 'hero' };
    
    // NPCの色定義 (カラフルな7色)
    const NPC_COLORS = {
        'npc1': '#f44336', // 赤
        'npc2': '#ff9800', // オレンジ
        'npc3': '#ffeb3b', // 黄(金)
        'npc4': '#4caf50', // 緑
        'npc5': '#2196f3', // 青
        'npc6': '#9c27b0', // 紫
        'npc7': '#e91e63'  // ピンク
    };

    const STATE = {
        EXPLORING: 0,
        DIALOGUE: 1,
        CHOICE: 2,
        ANIMATING: 3,
        TITLE: 4,
        HINT: 5
    };

    let currentState = STATE.TITLE; // 初期状態をタイトルに

    const MAP_DATA = [
        // MAP 0: 古語の間
        {
            id: 0,
            name: "古語の間",
            playerStart: { x: 2, y: 13 },
            layout: [
                [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
                [4,3,3,3,4,3,3,3,4,3,3,3,4,3,3,3,3,3,3,4],
                [4,3,9,3,4,3,9,3,4,3,9,3,4,3,9,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,4],
                [4,3,9,3,4,3,3,3,3,3,3,3,4,3,9,3,3,3,3,4],
                [4,3,3,3,4,3,9,3,3,9,3,3,4,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,9,3,4,3,9,3,3,9,3,3,4,3,9,3,3,3,3,4],
                [4,3,3,3,4,3,3,3,3,3,3,3,4,3,3,3,3,3,3,4],
                [4,3,3,3,4,4,4,4,3,4,4,4,4,3,3,3,3,3,3,4],
                [4,3,9,3,3,3,3,3,3,3,3,3,3,3,9,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,4],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: []
        },
        
        // MAP 1: 読みの間
        {
            id: 1,
            name: "読みの間",
            playerStart: { x: 9, y: 14 },
            layout: [
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
                [1,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,1],
                [1,4,0,0,0,0,1,1,3,3,1,1,0,0,0,0,0,0,4,1],
                [1,4,0,9,0,0,1,1,3,3,1,1,0,0,9,0,0,0,4,1],
                [1,4,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,4,1],
                [1,4,1,1,0,0,1,1,3,3,1,1,0,0,1,1,1,1,4,1],
                [1,4,1,1,0,0,1,1,3,3,1,1,0,0,1,1,1,1,4,1],
                [1,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1],
                [1,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1],
                [1,4,1,1,0,0,1,1,3,3,1,1,0,0,1,1,1,1,4,1],
                [1,4,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,4,1],
                [1,4,0,9,0,0,0,0,3,3,0,0,0,0,9,0,0,0,4,1],
                [1,4,0,0,0,0,1,1,3,3,1,1,0,0,0,0,0,0,4,1],
                [1,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,1],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: []
        },
        
        // MAP 2: 旅の始まりの間
        {
            id: 2,
            name: "旅の始まりの間",
            playerStart: { x: 9, y: 14 },
            layout: [
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,0,3,3,0,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,1,1],
                [1,0,9,0,1,1,0,0,3,3,0,0,1,1,0,9,0,0,1,1],
                [1,0,0,0,1,1,0,0,3,3,0,0,1,1,0,0,0,0,1,1],
                [1,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,1,1],
                [1,1,1,1,1,1,1,4,3,3,4,1,1,1,1,1,1,1,1,1],
                [4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,4],
                [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
                [3,9,3,3,9,3,3,3,3,3,3,3,9,3,3,3,9,3,3,3],
                [4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,4],
                [4,2,2,4,4,2,2,4,3,3,4,2,2,4,4,2,2,4,4,4],
                [4,2,2,4,4,2,2,4,3,3,4,2,2,4,4,2,2,4,4,4],
                [4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,4],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: []
        },

        // MAP 3: 八橋の間
        {
            id: 3,
            name: "八橋の間",
            playerStart: { x: 2, y: 14 },
            layout: [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,1,1,1],
                [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,2,2,1],
                [1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,1],
                [1,2,3,9,3,2,2,2,2,2,2,2,2,3,9,3,2,2,2,1],
                [1,2,3,3,3,2,2,2,2,2,2,2,2,3,3,3,2,2,2,1],
                [1,2,2,3,2,2,2,2,2,2,2,2,2,2,3,2,2,2,2,1],
                [1,2,2,3,2,2,2,2,2,2,2,2,2,2,3,2,2,2,2,1],
                [1,2,2,3,3,3,3,3,3,9,3,3,3,3,3,2,2,2,2,1],
                [1,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,1],
                [1,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,1],
                [1,2,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,1],
                [1,2,3,9,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
                [1,2,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
                [1,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
                [1,1,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,1,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: []
        },

        // MAP 4: 宇津の山の間
        {
            id: 4,
            name: "宇津の山の間",
            playerStart: { x: 2, y: 14 },
            layout: [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,1,1,1],
                [1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,3,3,1,1,1],
                [1,1,1,1,1,1,0,9,0,9,0,0,1,1,1,3,3,1,1,1],
                [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,1,1,1],
                [1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1], // 中央付近を0にして通路作成
                [1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1],
                [1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1],
                [1,1,0,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1],
                [1,1,0,0,0,0,0,1,0,0,0,0,0,9,0,1,0,1,1,1],
                [1,1,0,1,1,1,1,1,0,1,1,1,0,0,0,1,0,1,1,1],//左から３つめを0にした
                [1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1],
                [1,1,0,9,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1],
                [1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1],
                [1,1,1,1,1,1,1,1,0,9,0,0,0,0,0,0,1,1,1,1],
                [1,1,3,3,3,3,3,3,0,0,0,0,1,1,1,1,1,1,1,1],
                [1,1,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: []
        },

        // MAP 5: 富士山の間
        {
            id: 5,
            name: "富士山の間",
            playerStart: { x: 8, y: 14 },
            layout: [
                [4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,4],
                [4,4,4,4,4,4,4,0,0,0,0,4,4,4,4,4,4,4,4,4],
                [4,4,4,4,4,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4],
                [4,4,4,4,0,0,0,0,9,9,0,0,0,0,4,4,4,4,4,4],
                [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4],
                [4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4],
                [4,0,0,0,0,9,0,0,0,0,0,0,9,0,0,0,0,4,4,4],
                [4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4],
                [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4],
                [1,1,0,0,9,0,0,0,0,0,0,0,0,9,0,0,0,0,0,1],
                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1],
                [1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: []
        },

        // MAP 6: 隅田川の間
        {
            id: 6,
            name: "隅田川の間",
            playerStart: { x: 9, y: 14 },
            layout: [
                [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
                [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
                [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
                [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
                [2,2,2,2,2,2,2,2,3,3,2,2,2,2,2,2,2,2,2,2],
                [2,2,2,2,2,2,3,3,9,9,3,3,2,2,2,2,2,2,2,2],
                [2,2,2,2,2,3,3,3,9,9,3,3,3,2,2,2,2,2,2,2],
                [2,2,2,2,2,3,3,9,9,9,9,3,3,2,2,2,2,2,2,2],
                [2,2,2,2,2,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2],
                [2,2,2,2,2,2,2,2,3,3,2,2,2,2,2,2,2,2,2,2],
                [2,2,2,2,2,2,2,2,3,3,2,2,2,2,2,2,2,2,2,2],
                [2,2,2,0,0,0,0,0,3,3,0,0,0,0,0,0,0,2,2,2],
                [2,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,2],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1],
            ],
            entities: []
        }
    ];

    let currentMapId = 0;
    let currentMap = MAP_DATA[currentMapId];
    let entities = currentMap.entities;

    let player = {
        x: currentMap.playerStart.x,
        y: currentMap.playerStart.y,
        direction: 'down',
        stepState: 0
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const messageWindow = document.getElementById('message-window');
    const messageText = document.getElementById('message-text');
    const messageCursor = document.getElementById('message-cursor');
    const messageOkBtn = document.getElementById('message-ok-btn');
    const quizWindow = document.getElementById('quiz-window');
    const quizQuestion = document.getElementById('quiz-question');
    const quizChoices = document.getElementById('quiz-choices');
    const quizOkBtn = document.getElementById('quiz-ok-btn');
    const menuBtn = document.getElementById('menu-btn');
    
    // タイトル画面関連
    const titleScreen = document.getElementById('title-screen');
    const levelList = document.getElementById('level-list');
    let titleCursorIndex = 0;
    let clearedMaps = new Set(); // クリア済みのマップIDを保持
    let savedProgress = {}; // { mapId: [list_of_alive_npc_indices] }

    let currentChoiceIndex = -1; 
    let confettiParticles = [];
    
    let currentQuizData = null;
    let currentQuizEntity = null;
    let textAnimationTimer = null;
    let fullText = "";
    let isWaitingForEnter = false;
    let textCallback = null;
    let gameStarted = false;
    
    // システム用選択肢のコールバック
    let systemChoiceCallback = null;

    // 起動時にCSVを自動読み込み
    window.addEventListener('DOMContentLoaded', () => {
        loadCSVFile();
    });

    // データの読み込み
    function loadSaveData() {
        // クリアデータの読み込み
        const savedCleared = localStorage.getItem('heroQuizClearedMaps');
        if (savedCleared) {
            try {
                const arr = JSON.parse(savedCleared);
                clearedMaps = new Set(arr);
            } catch (e) {
                console.error("Save data parse error (clearedMaps)", e);
                clearedMaps = new Set();
            }
        }
        
        // 途中経過データの読み込み
        const savedProg = localStorage.getItem('heroQuizProgress');
        if (savedProg) {
            try {
                savedProgress = JSON.parse(savedProg);
            } catch (e) {
                console.error("Save data parse error (progress)", e);
                savedProgress = {};
            }
        } else {
            savedProgress = {};
        }
    }

    // クリアデータの保存
    function saveClearStatus(mapId) {
        clearedMaps.add(mapId);
        // クリアしたら途中経過は削除
        if (savedProgress[mapId]) {
            delete savedProgress[mapId];
            localStorage.setItem('heroQuizProgress', JSON.stringify(savedProgress));
        }
        localStorage.setItem('heroQuizClearedMaps', JSON.stringify(Array.from(clearedMaps)));
    }

    // 途中経過の保存
    function saveProgress(mapId) {
        // まだ倒されていない（クイズを完了していない）NPCの originalIndex を保存
        const aliveNPCs = currentMap.entities
            .filter(e => !e.quizCompleted && !e.removed)
            .map(e => e.originalIndex);
            
        savedProgress[mapId] = aliveNPCs;
        localStorage.setItem('heroQuizProgress', JSON.stringify(savedProgress));

        // もし既にクリア済みのマップだった場合、途中経過を保存したことで「クリア済み」を解除する
        if (clearedMaps.has(mapId)) {
            clearedMaps.delete(mapId);
            localStorage.setItem('heroQuizClearedMaps', JSON.stringify(Array.from(clearedMaps)));
        }
    }

    // 特定のマップデータを削除する関数
    function deleteMapData(mapId) {
        // クリアデータの削除
        if (clearedMaps.has(mapId)) {
            clearedMaps.delete(mapId);
            localStorage.setItem('heroQuizClearedMaps', JSON.stringify(Array.from(clearedMaps)));
        }
        
        // 中断データの削除
        if (savedProgress[mapId]) {
            delete savedProgress[mapId];
            localStorage.setItem('heroQuizProgress', JSON.stringify(savedProgress));
        }
    }

    // すべての記録を削除
    function confirmDeleteAllData() {
        if (confirm("本当にすべての戦績を削除しますか？\n（クリア状況や中断データが全て消えます）")) {
            localStorage.removeItem('heroQuizClearedMaps');
            localStorage.removeItem('heroQuizProgress');
            clearedMaps = new Set();
            savedProgress = {};
            showTitleScreen(); // 画面更新
        }
    }

    async function loadCSVFile() {
        const loadingMessage = document.getElementById('loading-message');
        
        try {
            // quiz.csvをfetchで読み込み
            const response = await fetch('quiz.csv');
            
            if (!response.ok) {
                throw new Error(`CSVファイルが見つかりません (${response.status})`);
            }
            
            const csvText = await response.text();
            loadingMessage.textContent = 'CSVを解析中...';
            
            // 少し待ってから解析
            setTimeout(() => {
                parseCSVAndInit(csvText);
            }, 500);
            
        } catch (error) {
            loadingMessage.innerHTML = `
                <span style="color: #f44336;">エラー: ${error.message}</span><br>
                <span style="font-size: 12px; margin-top: 10px; display: block;">
                    HTMLファイルと同じフォルダに「quiz.csv」を配置してください<br>
                    形式: map_id,sprite,question,option,correct,hint
                </span>
            `;
            console.error('CSV読み込みエラー:', error);
        }
    }

    function parseCSVAndInit(csvText) {
        const lines = csvText.trim().split('\n');
        const headers = lines[0].split(',').map(h => h.trim());
        
        // name列がなくなったため、headerのチェック対象も変更
        const essentialHeaders = ['map_id', 'sprite', 'question', 'option', 'correct'];
        const hasValidHeaders = essentialHeaders.every(h => headers.includes(h));
        
        if (!hasValidHeaders) {
            alert('CSVの形式が正しくありません。\n必要な列: map_id,sprite,question,option,correct\n(hint列は任意)');
            return;
        }
        
        const npcsData = [];
        for (let i = 1; i < lines.length; i++) {
            if (!lines[i].trim()) continue;
            
            // CSVのパース（簡易版）
            const values = lines[i].split(',').map(v => v.trim());
            
            // name列がなくなったので、インデックスがずれる
            // 0:map_id, 1:sprite, 2:question, 3:option, 4:correct, 5:hint
            if (values.length < 5) continue;

            const npc = {
                map_id: parseInt(values[0]),
                // nameはなし
                sprite: values[1],
                question: values[2],
                option: values[3],
                correct: parseInt(values[4]),
                hint: values[5] ? values[5].trim() : ""
            };
            npcsData.push(npc);
        }
        
        generateNPCsFromCSV(npcsData);
        
        document.getElementById('loading-screen').style.display = 'none';
        
        // データの読み込みとタイトル画面の表示
        loadSaveData();
        showTitleScreen();
    }
    
    // タイトル画面の表示
    function showTitleScreen() {
        currentState = STATE.TITLE;
        confettiParticles = []; // 紙吹雪をリセット
        titleScreen.style.display = 'flex';
        levelList.innerHTML = '';
        menuBtn.style.display = 'none'; // タイトルではメニューボタン非表示
        
        // 再度ロードして最新の状態にする（ゲームから戻ったとき用）
        loadSaveData();

        MAP_DATA.forEach((map, index) => {
            const li = document.createElement('li');
            li.className = 'level-item';
            
            let label = map.name;
            
            // クリア済みか、途中データがあるかチェック
            if (clearedMaps.has(map.id)) {
                label += ' ★';
            } else if (savedProgress[map.id]) {
                const remaining = savedProgress[map.id].length;
                label += ` (残り${remaining}体)`;
            }
            
            li.textContent = label;
            
            if (index === titleCursorIndex) li.classList.add('selected');

            li.onclick = () => {
                startGame(index);
            };
            
            li.onmouseover = () => {
                updateTitleCursor(index);
            };

            levelList.appendChild(li);
        });

        // 「すべての記録を削除する」ボタンの追加
        const deleteLi = document.createElement('li');
        deleteLi.className = 'level-item';
        deleteLi.textContent = "【すべての戦績を削除する】";
        deleteLi.style.color = "#ff6666"; // 赤色で区別
        
        // タイトルカーソルがこの位置にある場合
        if (titleCursorIndex === MAP_DATA.length) {
            deleteLi.classList.add('selected');
        }

        deleteLi.onclick = () => {
            confirmDeleteAllData();
        };

        deleteLi.onmouseover = () => {
            updateTitleCursor(MAP_DATA.length);
        };

        levelList.appendChild(deleteLi);
    }

    function updateTitleCursor(index) {
        const items = levelList.getElementsByClassName('level-item');
        if (index >= 0 && index < items.length) {
            // 前の選択を外す
            if (items[titleCursorIndex]) {
                items[titleCursorIndex].classList.remove('selected');
            }
            
            titleCursorIndex = index;
            items[titleCursorIndex].classList.add('selected');
            
            // スクロール調整
            items[titleCursorIndex].scrollIntoView({ block: 'nearest' });
        }
    }

    function startGame(mapId) {
        // 範囲外チェック（削除ボタンのインデックスなどが渡された場合用）
        if (mapId < 0 || mapId >= MAP_DATA.length) return;

        titleScreen.style.display = 'none';
        menuBtn.style.display = 'block'; // ゲーム中はメニューボタン表示
        gameStarted = true;
        
        // マップ初期化
        currentMapId = mapId;
        currentMap = MAP_DATA[currentMapId];
        
        // エンティティの状態をリセット (まずは全員復活)
        resetMapEntities(currentMap);
        
        // 途中セーブデータがある場合は、倒した敵を消す
        if (savedProgress[mapId]) {
            const aliveList = savedProgress[mapId];
            
            currentMap.entities.forEach(e => {
                // セーブデータに含まれていないID（originalIndex）の敵は、既に倒したとみなす
                if (!aliveList.includes(e.originalIndex)) {
                    e.removed = true;
                    e.quizCompleted = true;
                    e.blocking = false;
                }
            });
        }

        entities = currentMap.entities;
        player.x = currentMap.playerStart.x;
        player.y = currentMap.playerStart.y;
        player.direction = 'down';
        currentState = STATE.EXPLORING;
        
        // BGM的な演出として、少し待ってから開始
        setTimeout(() => {
            if (savedProgress[mapId]) {
                displayText(`勇者よ、${currentMap.name}の攻略を再開するのだ。`);
            } else {
                displayText(`勇者よ、${currentMap.name}に到着した。\nすべてのクイズに答えて進むのだ。`);
            }
        }, 300);
    }
    
    function resetMapEntities(map) {
        map.entities.forEach(e => {
            e.quizCompleted = false;
            e.removed = false;
            e.blocking = true;
            e.blinking = false;
        });
    }

    function generateNPCsFromCSV(npcsData) {
        const npcsByMap = {};
        npcsData.forEach(npc => {
            if (!npcsByMap[npc.map_id]) {
                npcsByMap[npc.map_id] = [];
            }
            npcsByMap[npc.map_id].push(npc);
        });
        
        Object.keys(npcsByMap).forEach(mapId => {
            const mapIndex = parseInt(mapId);
            if (mapIndex < 0 || mapIndex >= MAP_DATA.length) return;
            
            const map = MAP_DATA[mapIndex];
            const npcs = npcsByMap[mapId];
            
            // マップごとのNPCリストをリセットして再生成
            map.entities = [];

            npcs.forEach((npcData, index) => {
                // スプライト種類に応じた色の決定
                // npc1~npc7のどれか。デフォルトは灰色。
                const color = NPC_COLORS[npcData.sprite.toLowerCase()] || '#9e9e9e';
                
                const sprite = {
                    color: color,
                    type: 'villager' // すべてvillager形状に統一
                };
                
                const options = npcData.option.split(';').map(o => o.trim());
                const pos = findRandomWalkablePosition(map);
                
                if (pos) {
                    map.entities.push({
                        originalIndex: index, // セーブデータ照合用の一意なID (マップ内でのindex)
                        x: pos.x,
                        y: pos.y,
                        // nameなし
                        sprite: sprite,
                        blocking: true,
                        quiz: {
                            question: npcData.question,
                            options: options,
                            correct: npcData.correct,
                            hint: npcData.hint
                        }
                    });
                }
            });
        });
        
        if (gameStarted) {
            entities = currentMap.entities;
        }
    }

    function findRandomWalkablePosition(map) {
        const layout = map.layout;
        const playerStart = map.playerStart;
        const maxAttempts = 1000;
        
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const x = Math.floor(Math.random() * layout[0].length);
            const y = Math.floor(Math.random() * layout.length);
            
            const tile = layout[y][x];
            if (tile !== 0 && tile !== 3 && tile !== 9) continue;
            
            const dist = Math.abs(x - playerStart.x) + Math.abs(y - playerStart.y);
            if (dist < 3) continue;
            
            const overlap = map.entities.some(e => e.x === x && e.y === y);
            if (overlap) continue;
            
            return { x, y };
        }
        return null;
    }

    function resize() {
        const container = document.getElementById('game-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        ctx.imageSmoothingEnabled = false;
    }
    window.addEventListener('resize', resize);
    resize();

    const keys = {};
    let lastKeyTime = 0;
    const keyRepeatRate = 150;

    // メニューボタンイベント
    menuBtn.addEventListener('click', () => {
        // 探索中のみメニューを開ける
        if (currentState === STATE.EXPLORING) {
            askSystemQuestion("現在の戦績を追記しますか。", ["追記する", "追記しない", "このフロアの戦績を全部消す"], (choiceIndex) => {
                if (choiceIndex === 0) { // 追記する
                    saveProgress(currentMapId);
                    showTitleScreen();
                } else if (choiceIndex === 1) { // 追記しない
                    showTitleScreen();
                } else if (choiceIndex === 2) { // このフロアの戦績を全部消す
                    deleteMapData(currentMapId);
                    showTitleScreen();
                }
            });
        }
    });

    messageOkBtn.addEventListener('click', () => {
        if (currentState === STATE.DIALOGUE) {
            progressDialogue();
        }
    });

    quizOkBtn.addEventListener('click', () => {
        if (currentState === STATE.CHOICE && currentChoiceIndex !== -1) {
            confirmChoice();
        } else if (currentState === STATE.HINT) {
            returnToQuizFromHint();
        }
    });

    window.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        handleInput(e.code);
    });
    window.addEventListener('keyup', (e) => {
        keys[e.code] = false;
    });

    document.querySelectorAll('[data-key]').forEach(el => {
        el.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const key = el.getAttribute('data-key');
            keys[key] = true;
            handleInput(key);
        }, {passive: false});

        el.addEventListener('touchend', (e) => {
            e.preventDefault();
            const key = el.getAttribute('data-key');
            keys[key] = false;
        });
        
        el.addEventListener('mousedown', (e) => {
            const key = el.getAttribute('data-key');
            keys[key] = true;
            handleInput(key);
        });
        el.addEventListener('mouseup', (e) => {
            const key = el.getAttribute('data-key');
            keys[key] = false;
        });
    });

    function handleInput(code) {
        if (STATE.TITLE === currentState) {
            handleTitleInput(code);
        } else if (STATE.EXPLORING === currentState) {
            // 探索中の操作
        } else if (STATE.DIALOGUE === currentState) {
            handleDialogueInput(code);
        } else if (STATE.CHOICE === currentState) {
            handleChoiceInput(code);
        } else if (STATE.HINT === currentState) {
            handleHintInput(code);
        }
    }

    function handleTitleInput(code) {
        // levelListの子要素数を取得（マップ数 + 削除ボタン）
        const maxIndex = levelList.childElementCount - 1;

        if (code === 'ArrowUp') {
            updateTitleCursor(Math.max(0, titleCursorIndex - 1));
        } else if (code === 'ArrowDown') {
            updateTitleCursor(Math.min(maxIndex, titleCursorIndex + 1));
        } else if (code === 'Enter' || code === 'Space' || code === 'KeyZ') {
            // 一番最後（マップ数と同じインデックス）は削除ボタン
            if (titleCursorIndex === MAP_DATA.length) {
                confirmDeleteAllData();
            } else {
                startGame(titleCursorIndex);
            }
        }
    }

    function handleDialogueInput(code) {
        if (code === 'Enter' || code === 'Space' || code === 'KeyZ') {
            progressDialogue();
        }
    }

    function handleHintInput(code) {
        const scrollAmount = 30;
        if (code === 'ArrowUp') {
            quizQuestion.scrollTop -= scrollAmount;
        } else if (code === 'ArrowDown') {
            quizQuestion.scrollTop += scrollAmount;
        } else if (code === 'Enter' || code === 'Space' || code === 'KeyZ') {
            returnToQuizFromHint();
        }
    }

    function progressDialogue() {
        if (isWaitingForEnter) {
            if (textCallback) {
                const cb = textCallback;
                textCallback = null;
                cb();
            } else {
                closeDialogue();
            }
        } else {
            if (textAnimationTimer) {
                clearInterval(textAnimationTimer);
                messageText.innerHTML = fullText.replace(/\n/g, '<br>');
                isWaitingForEnter = true;
                messageCursor.style.display = 'inline-block';
                messageOkBtn.style.display = 'block';
            }
        }
    }

    function handleChoiceInput(code) {
        const hasHint = currentQuizData.hint && currentQuizData.hint.trim() !== "";
        // システム用クイズの場合はhintはない
        const totalOptions = currentQuizData.options.length + (hasHint && !systemChoiceCallback ? 1 : 0);

        if (code === 'ArrowUp') {
            if (currentChoiceIndex === -1) {
                currentChoiceIndex = totalOptions - 1;
            } else {
                currentChoiceIndex = Math.max(0, currentChoiceIndex - 1);
            }
            renderChoices();
        } else if (code === 'ArrowDown') {
            if (currentChoiceIndex === -1) {
                currentChoiceIndex = 0;
            } else {
                currentChoiceIndex = Math.min(totalOptions - 1, currentChoiceIndex + 1);
            }
            renderChoices();
        } 
        else if (code === 'Enter' || code === 'Space' || code === 'KeyZ') {
            if (currentChoiceIndex !== -1) {
                confirmChoice();
            }
        }
    }

    function isWalkable(x, y) {
        const mapLayout = currentMap.layout;
        if (y < 0 || y >= mapLayout.length || x < 0 || x >= mapLayout[0].length) return false;
        
        const tile = mapLayout[y][x];
        if (tile === 1 || tile === 2 || tile === 4) return false;

        for (let e of entities) {
            if (e.x === x && e.y === y && e.blocking && !e.removed) return false;
        }
        
        return true;
    }

    function update() {
        if (currentState === STATE.EXPLORING) {
            movePlayer();
            checkAutoInteraction();
        }
    }

    function movePlayer() {
        const now = Date.now();
        if (now - lastKeyTime < keyRepeatRate) return;

        let dx = 0;
        let dy = 0;
        let moved = false;

        if (keys['ArrowUp']) { dy = -1; player.direction = 'up'; moved = true; }
        else if (keys['ArrowDown']) { dy = 1; player.direction = 'down'; moved = true; }
        else if (keys['ArrowLeft']) { dx = -1; player.direction = 'left'; moved = true; }
        else if (keys['ArrowRight']) { dx = 1; player.direction = 'right'; moved = true; }

        if (moved) {
            const newX = player.x + dx;
            const newY = player.y + dy;

            if (isWalkable(newX, newY)) {
                player.x = newX;
                player.y = newY;
                player.stepState = (player.stepState + 1) % 2;
            }
            lastKeyTime = now;
        }
    }

    function checkAutoInteraction() {
        const directions = [
            {dx: 0, dy: -1}, {dx: 0, dy: 1},
            {dx: -1, dy: 0}, {dx: 1, dy: 0},
            {dx: -1, dy: -1}, {dx: 1, dy: -1},
            {dx: -1, dy: 1}, {dx: 1, dy: 1}
        ];

        for (let dir of directions) {
            const targetX = player.x + dir.dx;
            const targetY = player.y + dir.dy;
            
            const targetEntity = entities.find(e => 
                e.x === targetX && 
                e.y === targetY && 
                !e.removed && 
                e.quiz && 
                !e.quizCompleted
            );

            if (targetEntity) {
                startQuiz(targetEntity);
                return;
            }
        }
    }

    function displayText(text, callback = null) {
        currentState = STATE.DIALOGUE;
        messageWindow.style.display = 'block';
        messageText.innerHTML = '';
        messageCursor.style.display = 'none';
        messageOkBtn.style.display = 'none';
        
        fullText = text;
        textCallback = callback;
        isWaitingForEnter = false;

        let i = 0;
        if (textAnimationTimer) clearInterval(textAnimationTimer);

        textAnimationTimer = setInterval(() => {
            messageText.innerHTML = fullText.substring(0, i + 1).replace(/\n/g, '<br>');
            i++;
            if (i >= fullText.length) {
                clearInterval(textAnimationTimer);
                isWaitingForEnter = true;
                messageCursor.style.display = 'inline-block';
                messageOkBtn.style.display = 'block';
            }
        }, 30);
    }

    function closeDialogue() {
        messageWindow.style.display = 'none';
        messageOkBtn.style.display = 'none';
        quizWindow.style.display = 'none';
        quizOkBtn.style.display = 'none';
        currentState = STATE.EXPLORING;
        textCallback = null;
    }

    function pushPlayerBack() {
        let dx = 0, dy = 0;
        if (player.direction === 'up') dy = 1;
        if (player.direction === 'down') dy = -1;
        if (player.direction === 'left') dx = 1;
        if (player.direction === 'right') dx = -1;

        if (isWalkable(player.x + dx, player.y + dy)) {
            player.x += dx;
            player.y += dy;
        }
        closeDialogue();
    }

    function startQuiz(entity) {
        currentState = STATE.CHOICE;
        currentQuizData = entity.quiz;
        currentQuizEntity = entity;
        currentChoiceIndex = 0;
        systemChoiceCallback = null; 

        quizWindow.style.display = 'flex';
        quizQuestion.innerHTML = currentQuizData.question.replace(/\n/g, '<br>');
        quizQuestion.scrollTop = 0;
        renderChoices();
        quizOkBtn.style.display = 'block';
    }

    // システム的な問いかけ（Yes/Noなど）を行う関数
    function askSystemQuestion(text, options, callback) {
        currentState = STATE.CHOICE;
        systemChoiceCallback = callback;
        // hintなしのダミーデータ
        currentQuizData = { options: options, hint: "" }; 
        currentQuizEntity = null;
        currentChoiceIndex = 0;

        quizWindow.style.display = 'flex';
        quizQuestion.innerHTML = text.replace(/\n/g, '<br>');
        quizQuestion.scrollTop = 0;
        renderChoices();
        quizOkBtn.style.display = 'block';
    }

    function renderChoices() {
        quizChoices.innerHTML = '';
        
        const hasHint = currentQuizData.hint && currentQuizData.hint.trim() !== "";
        // システムコールバックがある時はヒントボタンを出さない
        const showHintBtn = hasHint && !systemChoiceCallback;
        
        // 通常の選択肢を描画
        currentQuizData.options.forEach((opt, index) => {
            const li = document.createElement('li');
            li.className = 'choice-item ' + (index === currentChoiceIndex ? 'selected' : '');
            li.textContent = opt;
            
            li.onclick = () => {
                currentChoiceIndex = index; 
                renderChoices(); 
                confirmChoice();
            };
            
            li.onmouseover = () => {
                if (currentState === STATE.CHOICE) {
                    currentChoiceIndex = index;
                    renderChoices(); 
                }
            }

            quizChoices.appendChild(li);
        });

        // ヒントがある場合は最後に「解説を見る」を追加
        if (showHintBtn) {
            const hintIndex = currentQuizData.options.length;
            const li = document.createElement('li');
            li.className = 'choice-item hint-btn ' + (hintIndex === currentChoiceIndex ? 'selected' : '');
            li.textContent = '解説を見る';

            li.onclick = () => {
                currentChoiceIndex = hintIndex;
                renderChoices();
                confirmChoice();
            };

            li.onmouseover = () => {
                if (currentState === STATE.CHOICE) {
                    currentChoiceIndex = hintIndex;
                    renderChoices();
                }
            }
            quizChoices.appendChild(li);
        }
    }

    function confirmChoice() {
        if (currentChoiceIndex === -1) return;

        // ヒント表示の判定
        const hasHint = currentQuizData.hint && currentQuizData.hint.trim() !== "";
        const showHintBtn = hasHint && !systemChoiceCallback;
        const isHintSelected = showHintBtn && (currentChoiceIndex === currentQuizData.options.length);

        if (isHintSelected) {
            showHint();
            return;
        }

        const selectedIndex = currentChoiceIndex;
        
        // システム選択肢のコールバックがある場合
        if (systemChoiceCallback) {
            currentChoiceIndex = -1;
            quizWindow.style.display = 'none';
            quizOkBtn.style.display = 'none';
            
            const cb = systemChoiceCallback;
            systemChoiceCallback = null;
            currentState = STATE.EXPLORING; // 一旦ステートを戻す
            cb(selectedIndex);
            return;
        }

        // 通常のNPCクイズ処理
        currentChoiceIndex = -1;
        quizWindow.style.display = 'none';
        quizOkBtn.style.display = 'none';

        if (selectedIndex === currentQuizData.correct) {
            currentQuizEntity.quizCompleted = true;
            
            blinkAndRemoveNPC(currentQuizEntity, () => {
                checkMapClear();
            });
        } else {
            displayText("「違うな。出直してこい!」", () => {
                pushPlayerBack();
            });
        }
    }

    function showHint() {
        currentState = STATE.HINT;
        quizChoices.innerHTML = ''; 
        quizQuestion.innerHTML = `【解説】<br>${currentQuizData.hint.replace(/\n/g, '<br>')}`;
        quizQuestion.scrollTop = 0; 
        quizOkBtn.style.display = 'block';
    }

    function returnToQuizFromHint() {
        currentState = STATE.CHOICE;
        quizQuestion.innerHTML = currentQuizData.question.replace(/\n/g, '<br>');
        quizQuestion.scrollTop = 0;
        renderChoices();
    }

    function blinkAndRemoveNPC(npc, callback) {
        let blinkCount = 0;
        const maxBlinks = 6;
        
        const blinkInterval = setInterval(() => {
            npc.blinking = !npc.blinking;
            blinkCount++;
            
            if (blinkCount >= maxBlinks) {
                clearInterval(blinkInterval);
                npc.removed = true;
                npc.blocking = false;
                if (callback) callback();
            }
        }, 150);
    }

    function checkMapClear() {
        const allCompleted = entities.every(e => !e.quiz || e.quizCompleted || e.removed);
        
        if (allCompleted) {
            // クリアデータを保存
            saveClearStatus(currentMapId);
            
            // 紙吹雪演出
            createConfetti();

            displayText(`このフロアをクリアした!\nメニューに戻ります。`, () => {
                closeDialogue();
                // 少し待ってからタイトルへ遷移
                setTimeout(() => {
                    showTitleScreen();
                }, 500);
            });
        } else {
            closeDialogue();
        }
    }

    function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const scale = canvas.width / (VIEW_WIDTH * TILE_SIZE);
        
        ctx.save();
        ctx.scale(scale, scale);

        const camX = player.x * TILE_SIZE - (VIEW_WIDTH * TILE_SIZE) / 2 + TILE_SIZE / 2;
        const camY = player.y * TILE_SIZE - (VIEW_HEIGHT * TILE_SIZE) / 2 + TILE_SIZE / 2;

        ctx.translate(-camX, -camY);

        const mapLayout = currentMap.layout;
        for (let y = 0; y < mapLayout.length; y++) {
            for (let x = 0; x < mapLayout[y].length; x++) {
                drawTile(x, y, mapLayout[y][x]);
            }
        }

        entities.forEach(ent => {
            if (!ent.removed && !ent.blinking) {
                drawSprite(ent.x, ent.y, ent.sprite);
            } else if (ent.blinking) {
                if (Math.random() > 0.5) {
                    drawSprite(ent.x, ent.y, ent.sprite);
                }
            }
        });

        // タイトル画面時はプレイヤーを描画しない、または動かない状態で描画する
        drawSprite(player.x, player.y, SPRITE_HERO, true);

        ctx.restore();

        if (confettiParticles.length > 0) {
            updateAndDrawConfetti();
        }

        requestAnimationFrame(draw);
    }

    function drawTile(x, y, type) {
        const px = x * TILE_SIZE;
        const py = y * TILE_SIZE;

        let color = '#000';
        switch (type) {
            case 0: color = COLOR_GRASS; break;
            case 1: color = COLOR_TREE; break;
            case 2: color = COLOR_WATER; break;
            case 3: 
            case 9: color = COLOR_FLOOR; break;
            case 4: color = COLOR_WALL; break;
        }

        ctx.fillStyle = color;
        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

        if (type === 1) {
            ctx.fillStyle = '#2e7d32';
            ctx.fillRect(px + 8, py + 8, 16, 16);
        } else if (type === 4) {
            ctx.strokeStyle = '#5d4037';
            ctx.strokeRect(px+2, py+2, TILE_SIZE-4, TILE_SIZE-4);
        } else if (type === 2) {
            if (Date.now() % 1000 < 500) {
                ctx.fillStyle = '#4fc3f7';
                ctx.fillRect(px + 5, py + 5, 5, 2);
            }
        }
    }

    function drawSprite(gridX, gridY, sprite, isPlayer = false) {
        const px = gridX * TILE_SIZE;
        const py = gridY * TILE_SIZE;

        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(px + 16, py + 26, 10, 4, 0, 0, Math.PI * 2);
        ctx.fill();

        let offset = 0;
        if (isPlayer && currentState === STATE.EXPLORING && (keys['ArrowUp'] || keys['ArrowDown'] || keys['ArrowLeft'] || keys['ArrowRight'])) {
             offset = (Date.now() % 200 < 100) ? -2 : 0;
        }

        ctx.fillStyle = sprite.color;
        ctx.fillRect(px + 8, py + 4 + offset, 16, 14);
        
        ctx.fillStyle = '#000';
        ctx.fillRect(px + 8, py + 18 + offset, 6, 8);
        ctx.fillRect(px + 18, py + 18 + offset, 6, 8);
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(px + 10, py + 8 + offset, 4, 4);
        ctx.fillRect(px + 18, py + 8 + offset, 4, 4);
        ctx.fillStyle = '#000';
        
        if (isPlayer) {
             let eyeOffsetX = 1;
             if (player.direction === 'left') eyeOffsetX = 0;
             if (player.direction === 'right') eyeOffsetX = 2;
             
             ctx.fillRect(px + 10 + eyeOffsetX, py + 9 + offset, 2, 2);
             ctx.fillRect(px + 18 + eyeOffsetX, py + 9 + offset, 2, 2);
        } else {
             ctx.fillRect(px + 11, py + 9 + offset, 2, 2);
             ctx.fillRect(px + 19, py + 9 + offset, 2, 2);
        }
        
        // 固有のタイプ別描画処理は削除し、形状を統一
    }

    function createConfetti() {
        confettiParticles = [];
        
        for(let i = 0; i < 50; i++) {
            confettiParticles.push({
                x: Math.random() * canvas.width,
                y: -20 - Math.random() * 100,
                vx: (Math.random() - 0.5) * 2,
                vy: Math.random() * 2 + 1,
                size: Math.random() * 8 + 3,
                color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.2
            });
        }
    }

    function updateAndDrawConfetti() {
        for (let i = confettiParticles.length - 1; i >= 0; i--) {
            const p = confettiParticles[i];
            
            p.x += p.vx;
            p.y += p.vy;
            p.rotation += p.rotationSpeed;
            
            if (p.y > canvas.height + 20) {
                confettiParticles.splice(i, 1);
                continue;
            }
            
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation);
            ctx.fillStyle = p.color;
            ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
            ctx.restore();
        }
    }

    setInterval(update, 1000 / 60);
    requestAnimationFrame(draw);

</script>
</body>
</html>