<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>勇者のクイズ冒険</title>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #000;
            --text-color: #fff;
            --border-color: #fff;
            --accent-color: #f8b500;
            --btn-red: rgba(200, 50, 50, 0.8);
            --btn-blue: rgba(50, 50, 200, 0.8);
            --btn-green: rgba(50, 150, 50, 0.8);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            color: var(--text-color);
            font-family: 'DotGothic16', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            max-height: calc(100dvh - 30px);
            aspect-ratio: 3/4;
            background-color: var(--bg-color);
            border: 2px solid #444;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            overflow: hidden;
            margin: auto;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .ui-box {
            position: absolute;
            background: #000;
            border: 4px double var(--border-color);
            border-radius: 4px;
            padding: 10px;
            box-sizing: border-box;
            display: none;
        }

        /* --- タイトル画面（フロア選択） --- */
        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #title-message {
            font-size: 16px;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        #level-list {
            list-style: none;
            padding: 0;
            margin: 0;
            width: 100%;
            max-width: 400px;
            max-height: 60vh;
            overflow-y: auto;
            border: 2px solid #444;
        }

        .level-item {
            padding: 12px;
            cursor: pointer;
            border-bottom: 1px solid #333;
            transition: background 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .level-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .level-item.selected {
            background-color: rgba(248, 181, 0, 0.3);
            border-left: 4px solid var(--accent-color);
            padding-left: 8px;
        }
        
        .level-item.selected .level-name::before {
            content: '▶ ';
            color: var(--accent-color);
        }
        
        .level-name {
            flex-grow: 1;
        }

        .reset-btn {
            background: #d32f2f;
            color: white;
            border: 1px solid #fff;
            padding: 2px 8px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
        .reset-btn:hover {
            background: #b71c1c;
        }

        #message-window {
            bottom: 160px;
            left: 5%;
            width: 90%;
            min-height: 120px;
            font-size: 18px;
            line-height: 1.6;
            z-index: 10;
            padding-bottom: 40px;
        }

        #message-ok-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: var(--btn-red);
            border: 2px solid #fff;
            border-radius: 4px;
            padding: 6px 16px;
            color: #fff;
            font-family: 'DotGothic16', sans-serif;
            font-size: 14px;
            cursor: pointer;
            user-select: none;
            display: none;
        }
        #message-ok-btn:active {
            background: rgba(255, 80, 80, 1);
        }

        #quiz-window {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 400px;
            max-height: 85vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 15;
            padding: 20px;
            padding-bottom: 60px; /* ボタンエリア確保 */
            display: none;
            flex-direction: column;
        }

        #quiz-question {
            font-size: 18px;
            margin-bottom: 15px;
            line-height: 1.5;
            white-space: pre-wrap;
            max-height: 50vh;
            overflow-y: auto;
            touch-action: pan-y;
            padding-right: 8px;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color) #333;
        }

        #quiz-question::-webkit-scrollbar { width: 6px; }
        #quiz-question::-webkit-scrollbar-track { background: #222; }
        #quiz-question::-webkit-scrollbar-thumb { background-color: var(--accent-color); border-radius: 3px; }

        #quiz-choices {
            list-style: none;
            padding: 0;
            margin: 0;
            margin-bottom: 10px;
            overflow-y: auto;
            max-height: 30vh;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color) #333;
        }

        #quiz-choices::-webkit-scrollbar { width: 6px; }
        #quiz-choices::-webkit-scrollbar-track { background: #222; }
        #quiz-choices::-webkit-scrollbar-thumb { background-color: var(--accent-color); border-radius: 3px; }

        .choice-item {
            padding: 10px;
            cursor: pointer;
            list-style: none;
            transition: background-color 0.1s;
            margin-bottom: 5px;
            border: 2px solid transparent;
        }
        
        .choice-item:hover { background-color: rgba(255, 255, 255, 0.1); }
        .choice-item.selected { background-color: rgba(255, 255, 255, 0.2); border-color: var(--accent-color); }
        .choice-item.selected::before { content: '▶'; margin-right: 5px; color: var(--accent-color); }
        .choice-item:not(.selected)::before { content: ' '; margin-right: 5px; }
        
        .choice-item.hint-btn { color: #81d4fa; border-top: 1px dashed #555; margin-top: 10px; }

        .quiz-btn-group {
            position: absolute;
            bottom: 8px;
            right: 8px;
            display: flex;
            gap: 10px;
        }

        .quiz-action-btn {
            background: var(--btn-red);
            border: 2px solid #fff;
            border-radius: 4px;
            padding: 6px 16px;
            color: #fff;
            font-family: 'DotGothic16', sans-serif;
            font-size: 14px;
            cursor: pointer;
            user-select: none;
            display: none; /* JSで制御 */
        }
        .quiz-action-btn:active { opacity: 0.8; }
        
        #quiz-transfer-btn { background: var(--btn-blue); }
        #quiz-return-btn { background: var(--btn-green); }

        .cursor-indicator {
            animation: blink 0.8s infinite;
            display: inline-block;
            margin-left: 5px;
            width: 10px;
            height: 10px;
            background-color: #fff;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* --- 仮想コントローラー (モバイル操作用) --- */
        #controls {
            position: absolute;
            bottom: 15px;
            left: 0;
            width: 100%;
            height: 140px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 20;
        }

        .d-pad {
            position: relative;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }

        .d-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 5px;
        }
        .d-btn:active { background: rgba(255, 255, 255, 0.5); }

        .d-up { top: 0; left: 40px; width: 40px; height: 40px; }
        .d-down { bottom: 0; left: 40px; width: 40px; height: 40px; }
        .d-left { top: 40px; left: 0; width: 40px; height: 40px; }
        .d-right { top: 40px; right: 0; width: 40px; height: 40px; }

        .action-pad {
            pointer-events: auto;
            display: flex;
            gap: 15px;
        }

        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: #fff;
            font-family: 'DotGothic16', sans-serif;
        }

        #loading-message {
            margin-top: 10px;
            font-size: 16px;
            text-align: center;
            white-space: pre-wrap;
        } 
        
        /* --- メニューボタン --- */
        #menu-btn {
            position: absolute;
            bottom: 15px; /* 右下隅 */
            right: 15px;
            background: rgba(50, 50, 200, 0.8);
            border: 2px solid #fff;
            border-radius: 4px;
            padding: 8px 12px;
            color: #fff;
            font-family: 'DotGothic16', sans-serif;
            font-size: 14px;
            cursor: pointer;
            z-index: 30; /* コントローラーより上 */
            user-select: none;
            display: none; /* 初期は非表示 */
        }
        #menu-btn:hover { background: rgba(80, 80, 220, 0.9); }
        #menu-btn:active { background: rgba(100, 100, 255, 1); }

    </style>
</head>
<body>

<div id="game-container">
    <div id="loading-screen">
        <h2 style="margin-top:0;">LOADING...</h2>
        <div id="loading-message">準備中...</div>
    </div>
    
    <!-- タイトル画面 / レベル選択 -->
    <div id="title-screen" style="display:none;">
        <h2 style="color:var(--accent-color); font-size: 24px;">言文クエスト</h2>
        <div id="title-message">攻略するフロアを選んでください。<br>（★:クリア済 / 数字:残り敵数）</div>
        <ul id="level-list">
            <!-- JSで生成 -->
        </ul>
    </div>

    <canvas id="gameCanvas"></canvas>
    
    <!-- メニューボタン -->
    <div id="menu-btn">メニューへ</div>

    <div id="message-window" class="ui-box">
        <div id="message-text"></div>
        <div id="message-cursor" class="cursor-indicator" style="display:none;"></div>
        <div id="message-ok-btn">OK</div>
    </div>

    <div id="quiz-window" class="ui-box">
        <div id="quiz-question"></div>
        <ul id="quiz-choices"></ul>
        <div class="quiz-btn-group">
            <div id="quiz-ok-btn" class="quiz-action-btn">OK</div>
            <div id="quiz-transfer-btn" class="quiz-action-btn">特訓行き</div>
            <div id="quiz-return-btn" class="quiz-action-btn">元のフロアに戻す</div>
        </div>
    </div>

    <div id="controls">
        <div class="d-pad">
            <div class="d-btn d-up" data-key="ArrowUp"></div>
            <div class="d-btn d-down" data-key="ArrowDown"></div>
            <div class="d-btn d-left" data-key="ArrowLeft"></div>
            <div class="d-btn d-right" data-key="ArrowRight"></div>
        </div>
        <div class="action-pad">
            <!-- ボタンなし -->
        </div>
    </div>
</div>

<script>
    const TILE_SIZE = 32;
    const VIEW_WIDTH = 15;
    const VIEW_HEIGHT = 15;

    const COLOR_GRASS = '#4caf50';
    const COLOR_TREE = '#1b5e20';
    const COLOR_WATER = '#0288d1';
    const COLOR_WALL = '#795548';
    const COLOR_FLOOR = '#3e2723';
    
    const SPRITE_HERO = { color: '#2196f3', type: 'hero' };
    
    const NPC_COLORS = {
        'npc1': '#f44336', // 赤
        'npc2': '#ff9800', // オレンジ
        'npc3': '#ffeb3b', // 黄(金)
        'npc4': '#4caf50', // 緑
        'npc5': '#2196f3', // 青
        'npc6': '#9c27b0', // 紫
        'npc7': '#e91e63'  // ピンク
    };

    const STATE = {
        EXPLORING: 0,
        DIALOGUE: 1,
        CHOICE: 2,
        ANIMATING: 3,
        TITLE: 4,
        HINT: 5
    };

    let currentState = STATE.TITLE;

    const MAP_DATA = [
        // MAP 0: 古語の間
        {
            id: 0,
            name: "古語の間",
            playerStart: { x: 2, y: 13 },
            layout: [
                [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
                [4,3,3,3,4,3,3,3,4,3,3,3,4,3,3,3,3,3,3,4],
                [4,3,9,3,4,3,9,3,4,3,9,3,4,3,9,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,4],
                [4,3,9,3,4,3,3,3,3,3,3,3,4,3,9,3,3,3,3,4],
                [4,3,3,3,4,3,9,3,3,9,3,3,4,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,9,3,4,3,9,3,3,9,3,3,4,3,9,3,3,3,3,4],
                [4,3,3,3,4,3,3,3,3,3,3,3,4,3,3,3,3,3,3,4],
                [4,3,3,3,4,4,4,4,3,4,4,4,4,3,3,3,3,3,3,4],
                [4,3,9,3,3,3,3,3,3,3,3,3,3,3,9,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,4],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: []
        },
        
        // MAP 1: 読みの間
        {
            id: 1,
            name: "読みの間",
            playerStart: { x: 9, y: 14 },
            layout: [
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
                [1,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,1],
                [1,4,0,0,0,0,1,1,3,3,1,1,0,0,0,0,0,0,4,1],
                [1,4,0,9,0,0,1,1,3,3,1,1,0,0,9,0,0,0,4,1],
                [1,4,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,4,1],
                [1,4,1,1,0,0,1,1,3,3,1,1,0,0,1,1,1,1,4,1],
                [1,4,1,1,0,0,1,1,3,3,1,1,0,0,1,1,1,1,4,1],
                [1,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1],
                [1,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1],
                [1,4,1,1,0,0,1,1,3,3,1,1,0,0,1,1,1,1,4,1],
                [1,4,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,4,1],
                [1,4,0,9,0,0,0,0,3,3,0,0,0,0,9,0,0,0,4,1],
                [1,4,0,0,0,0,1,1,3,3,1,1,0,0,0,0,0,0,4,1],
                [1,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,1],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: []
        },
        
        // MAP 2: 旅の始まりの間
        {
            id: 2,
            name: "旅の始まりの間",
            playerStart: { x: 9, y: 14 },
            layout: [
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,0,3,3,0,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,1,1],
                [1,0,9,0,1,1,0,0,3,3,0,0,1,1,0,9,0,0,1,1],
                [1,0,0,0,1,1,0,0,3,3,0,0,1,1,0,0,0,0,1,1],
                [1,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,1,1],
                [1,1,1,1,1,1,1,4,3,3,4,1,1,1,1,1,1,1,1,1],
                [4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,4],
                [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],
                [3,9,3,3,9,3,3,3,3,3,3,3,9,3,3,3,9,3,3,3],
                [4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,4],
                [4,2,2,4,4,2,2,4,3,3,4,2,2,4,4,2,2,4,4,4],
                [4,2,2,4,4,2,2,4,3,3,4,2,2,4,4,2,2,4,4,4],
                [4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,4],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: []
        },

        // MAP 3: 八橋の間
        {
            id: 3,
            name: "八橋の間",
            playerStart: { x: 2, y: 14 },
            layout: [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,1,1,1],
                [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,2,2,1],
                [1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,1],
                [1,2,3,9,3,2,2,2,2,2,2,2,2,3,9,3,2,2,2,1],
                [1,2,3,3,3,2,2,2,2,2,2,2,2,3,3,3,2,2,2,1],
                [1,2,2,3,2,2,2,2,2,2,2,2,2,2,3,2,2,2,2,1],
                [1,2,2,3,2,2,2,2,2,2,2,2,2,2,3,2,2,2,2,1],
                [1,2,2,3,3,3,3,3,3,9,3,3,3,3,3,2,2,2,2,1],
                [1,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,1],
                [1,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,1],
                [1,2,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,1],
                [1,2,3,9,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
                [1,2,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
                [1,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
                [1,1,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,1,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: []
        },

        // MAP 4: 宇津の山の間
        {
            id: 4,
            name: "宇津の山の間",
            playerStart: { x: 2, y: 14 },
            layout: [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,1,1,1],
                [1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,3,3,1,1,1],
                [1,1,1,1,1,1,0,9,0,9,0,0,1,1,1,3,3,1,1,1],
                [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,1,1,1],
                [1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1], 
                [1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1],
                [1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1],
                [1,1,0,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1],
                [1,1,0,0,0,0,0,1,0,0,0,0,0,9,0,1,0,1,1,1],
                [1,1,0,1,1,1,1,1,0,1,1,1,0,0,0,1,0,1,1,1],
                [1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1],
                [1,1,0,9,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1],
                [1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1],
                [1,1,1,1,1,1,1,1,0,9,0,0,0,0,0,0,1,1,1,1],
                [1,1,3,3,3,3,3,3,0,0,0,0,1,1,1,1,1,1,1,1],
                [1,1,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: []
        },

        // MAP 5: 富士山の間
        {
            id: 5,
            name: "富士山の間",
            playerStart: { x: 8, y: 14 },
            layout: [
                [4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,4],
                [4,4,4,4,4,4,4,0,0,0,0,4,4,4,4,4,4,4,4,4],
                [4,4,4,4,4,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4],
                [4,4,4,4,0,0,0,0,9,9,0,0,0,0,4,4,4,4,4,4],
                [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4],
                [4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4],
                [4,0,0,0,0,9,0,0,0,0,0,0,9,0,0,0,0,4,4,4],
                [4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4],
                [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4],
                [1,1,0,0,9,0,0,0,0,0,0,0,0,9,0,0,0,0,0,1],
                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1],
                [1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: []
        },

        // MAP 6: 隅田川の間
        {
            id: 6,
            name: "隅田川の間",
            playerStart: { x: 9, y: 14 },
            layout: [
                [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
                [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
                [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
                [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
                [2,2,2,2,2,2,2,2,3,3,2,2,2,2,2,2,2,2,2,2],
                [2,2,2,2,2,2,3,3,9,9,3,3,2,2,2,2,2,2,2,2],
                [2,2,2,2,2,3,3,3,9,9,3,3,3,2,2,2,2,2,2,2],
                [2,2,2,2,2,3,3,9,9,9,9,3,3,2,2,2,2,2,2,2],
                [2,2,2,2,2,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2],
                [2,2,2,2,2,2,2,2,3,3,2,2,2,2,2,2,2,2,2,2],
                [2,2,2,2,2,2,2,2,3,3,2,2,2,2,2,2,2,2,2,2],
                [2,2,2,0,0,0,0,0,3,3,0,0,0,0,0,0,0,2,2,2],
                [2,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,2],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1],
            ],
            entities: []
        },

        // MAP 7: 特訓会場（広間）
        {
            id: 7,
            name: "特訓会場",
            playerStart: { x: 9, y: 14 },
            layout: [
                [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,4,4],
                [1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1,1],
            ],
            entities: []
        }
    ];

    let currentMapId = 0;
    let currentMap = MAP_DATA[currentMapId];
    let entities = currentMap.entities;
    // CSVから読み込んだNPCデータの原本（各マップごと）
    let originalNPCsByMap = {}; 

    let player = {
        x: currentMap.playerStart.x,
        y: currentMap.playerStart.y,
        direction: 'down',
        stepState: 0
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const messageWindow = document.getElementById('message-window');
    const messageText = document.getElementById('message-text');
    const messageCursor = document.getElementById('message-cursor');
    const messageOkBtn = document.getElementById('message-ok-btn');
    const quizWindow = document.getElementById('quiz-window');
    const quizQuestion = document.getElementById('quiz-question');
    const quizChoices = document.getElementById('quiz-choices');
    const quizOkBtn = document.getElementById('quiz-ok-btn');
    const quizTransferBtn = document.getElementById('quiz-transfer-btn');
    const quizReturnBtn = document.getElementById('quiz-return-btn');
    const menuBtn = document.getElementById('menu-btn');
    
    // タイトル画面関連
    const titleScreen = document.getElementById('title-screen');
    const levelList = document.getElementById('level-list');
    let titleCursorIndex = 0;
    
    // データ管理
    // { mapId: { cleared: [ids], transferred: [ids] } }
    let savedProgress = {}; 
    let savedTrainingData = []; // [ {sourceMapId, sourceIndex, sprite, question, options, correct, hint, status} ]

    let currentChoiceIndex = -1; 
    let confettiParticles = [];
    
    let currentQuizData = null;
    let currentQuizEntity = null;
    let textAnimationTimer = null;
    let fullText = "";
    let isWaitingForEnter = false;
    let textCallback = null;
    let gameStarted = false;
    
    // システム用選択肢のコールバック
    let systemChoiceCallback = null;

    // 起動時にCSVを自動読み込み
    window.addEventListener('DOMContentLoaded', () => {
        loadCSVFile();
    });

    // データの読み込み
    function loadSaveData() {
        // 途中経過データの読み込み
        const savedProg = localStorage.getItem('heroQuizProgress');
        if (savedProg) {
            try {
                savedProgress = JSON.parse(savedProg);
                // データ構造のマイグレーション/チェック（配列からオブジェクトへ）
                Object.keys(savedProgress).forEach(key => {
                    if (Array.isArray(savedProgress[key])) {
                        // 旧形式（配列）の場合は一旦クリア（整合性のため）
                        savedProgress[key] = { cleared: [], transferred: [] };
                    }
                });
            } catch (e) {
                console.error("Save data parse error (progress)", e);
                savedProgress = {};
            }
        } else {
            savedProgress = {};
        }

        // トレーニングデータの読み込み
        const training = localStorage.getItem('heroQuizTraining');
        if (training) {
            try {
                savedTrainingData = JSON.parse(training);
            } catch (e) {
                console.error("Save data parse error (training)", e);
                savedTrainingData = [];
            }
        } else {
            savedTrainingData = [];
        }
    }

    // 正解として記録
    function saveClearedProgress(mapId, npcIndex) {
        if (!savedProgress[mapId]) {
            savedProgress[mapId] = { cleared: [], transferred: [] };
        }
        if (!savedProgress[mapId].cleared.includes(npcIndex)) {
            savedProgress[mapId].cleared.push(npcIndex);
            localStorage.setItem('heroQuizProgress', JSON.stringify(savedProgress));
        }
    }

    // 特訓行きとして記録
    function saveTransferredProgress(mapId, npcIndex) {
        if (!savedProgress[mapId]) {
            savedProgress[mapId] = { cleared: [], transferred: [] };
        }
        if (!savedProgress[mapId].transferred.includes(npcIndex)) {
            savedProgress[mapId].transferred.push(npcIndex);
            localStorage.setItem('heroQuizProgress', JSON.stringify(savedProgress));
        }
    }

    // トレーニングデータの保存
    function saveTrainingDataToStorage() {
        localStorage.setItem('heroQuizTraining', JSON.stringify(savedTrainingData));
    }

    // トレーニングデータから特定のNPCを削除（戻す）
    function removeNPCFromTraining(sourceMapId, sourceIndex) {
        // 1. トレーニングデータから削除
        savedTrainingData = savedTrainingData.filter(npc => 
            !(npc.sourceMapId === sourceMapId && npc.sourceIndex === sourceIndex)
        );
        saveTrainingDataToStorage();

        // 2. 元のマップの「特訓行き」記録から削除（復活させる）
        if (savedProgress[sourceMapId] && savedProgress[sourceMapId].transferred) {
            savedProgress[sourceMapId].transferred = savedProgress[sourceMapId].transferred.filter(id => id !== sourceIndex);
            localStorage.setItem('heroQuizProgress', JSON.stringify(savedProgress));
        }
    }
    
    // 特定のマップデータをリセットする関数
    function resetMapData(mapId) {
        // 特訓会場は別ロジック
        if (mapId === 7) return; 

        if (savedProgress[mapId]) {
            // A: 正答済みIDをすべて消す
            savedProgress[mapId].cleared = [];

            // B: 特訓行きとして記録されていたNPCについて
            const transferredIDs = savedProgress[mapId].transferred || [];
            
            // B-1: 特訓会場の方に記録されていた情報を消す
            savedTrainingData = savedTrainingData.filter(npc => 
                !(npc.sourceMapId === mapId && transferredIDs.includes(npc.sourceIndex))
            );
            saveTrainingDataToStorage();

            // B-2: そのフロアの記録エリアに、特訓行きとして記録されていたIDを消す
            savedProgress[mapId].transferred = [];
            
            localStorage.setItem('heroQuizProgress', JSON.stringify(savedProgress));
        }
        
        showTitleScreen();
    }

    // 特訓会場のリセット
    function resetTrainingRoom() {
        // 特訓会場にいるNPCについて
        savedTrainingData.forEach(npc => {
            if (savedProgress[npc.sourceMapId] && savedProgress[npc.sourceMapId].transferred) {
                // A: そのNPCが所属しているフロアで、特訓行きとして記録されていたIDを消す
                savedProgress[npc.sourceMapId].transferred = savedProgress[npc.sourceMapId].transferred.filter(id => id !== npc.sourceIndex);
            }
        });
        localStorage.setItem('heroQuizProgress', JSON.stringify(savedProgress));

        // B: そのNPCの、特訓会場に記録されていた情報を消す（全削除）
        savedTrainingData = [];
        saveTrainingDataToStorage();
        
        showTitleScreen();
    }

    // すべての記録を削除
    function confirmDeleteAllData() {
        if (confirm("本当にすべての戦績を削除しますか？")) {
            localStorage.removeItem('heroQuizProgress');
            localStorage.removeItem('heroQuizTraining');
            savedProgress = {};
            savedTrainingData = [];
            showTitleScreen(); // 画面更新
        }
    }

    async function loadCSVFile() {
        const loadingMessage = document.getElementById('loading-message');
        
        try {
            const response = await fetch('quiz.csv');
            if (!response.ok) {
                throw new Error(`CSVファイルが見つかりません (${response.status})`);
            }
            const csvText = await response.text();
            loadingMessage.textContent = 'CSVを解析中...';
            setTimeout(() => {
                parseCSVAndInit(csvText);
            }, 500);
            
        } catch (error) {
            loadingMessage.innerHTML = `
                <span style="color: #f44336;">エラー: ${error.message}</span><br>
                <span style="font-size: 12px; margin-top: 10px; display: block;">
                    HTMLファイルと同じフォルダに「quiz.csv」を配置してください<br>
                    形式: map_id,sprite,question,option,correct,hint
                </span>
            `;
            console.error('CSV読み込みエラー:', error);
        }
    }

    function parseCSVAndInit(csvText) {
        const lines = csvText.trim().split('\n');
        const headers = lines[0].split(',').map(h => h.trim());
        const essentialHeaders = ['map_id', 'sprite', 'question', 'option', 'correct'];
        const hasValidHeaders = essentialHeaders.every(h => headers.includes(h));
        
        if (!hasValidHeaders) {
            alert('CSVの形式が正しくありません。\n必要な列: map_id,sprite,question,option,correct\n(hint列は任意)');
            return;
        }
        
        const npcsData = [];
        for (let i = 1; i < lines.length; i++) {
            if (!lines[i].trim()) continue;
            
            const values = lines[i].split(',').map(v => v.trim());
            if (values.length < 5) continue;

            const npc = {
                map_id: parseInt(values[0]),
                sprite: values[1],
                question: values[2],
                option: values[3],
                correct: parseInt(values[4]),
                hint: values[5] ? values[5].trim() : ""
            };
            npcsData.push(npc);
        }
        
        // CSVデータをマップごとに整理して originalNPCsByMap に格納
        organizeNPCsByMap(npcsData);
        
        document.getElementById('loading-screen').style.display = 'none';
        
        loadSaveData();
        showTitleScreen();
    }

    function organizeNPCsByMap(npcsData) {
        originalNPCsByMap = {};
        npcsData.forEach((npc, index) => {
            if (!originalNPCsByMap[npc.map_id]) {
                originalNPCsByMap[npc.map_id] = [];
            }
        });

        // 配列に入れなおす
        Object.keys(originalNPCsByMap).forEach(key => originalNPCsByMap[key] = []); // 初期化

        npcsData.forEach(npc => {
            if (originalNPCsByMap[npc.map_id]) {
                originalNPCsByMap[npc.map_id].push(npc);
            } else {
                originalNPCsByMap[npc.map_id] = [npc];
            }
        });
    }
    
    // タイトル画面の表示
    function showTitleScreen() {
        currentState = STATE.TITLE;
        confettiParticles = [];
        titleScreen.style.display = 'flex';
        levelList.innerHTML = '';
        menuBtn.style.display = 'none';
        
        loadSaveData();

        MAP_DATA.forEach((map, index) => {
            const li = document.createElement('li');
            li.className = 'level-item';
            
            const nameSpan = document.createElement('span');
            nameSpan.className = 'level-name';
            
            let label = map.name;
            let countText = "";
            let showReset = false;

            if (map.id === 7) {
                // 特訓会場の場合
                const count = savedTrainingData.length;
                countText = `（現在${count}体）`;
                showReset = (count > 0);
            } else {
                // 通常マップの場合
                const total = (originalNPCsByMap[map.id] || []).length;
                
                const progressObj = savedProgress[map.id] || { cleared: [], transferred: [] };
                const clearedCount = progressObj.cleared.length;
                const transferredCount = progressObj.transferred.length;
                
                const remaining = total - clearedCount;
                
                // 表示ロジック
                if (clearedCount === 0 && transferredCount === 0) {
                    // 正答も特訓もいない場合は表示なし
                } else if (remaining === 0) {
                    label += ' ★';
                } else {
                    if (transferredCount > 0) {
                        countText = `（残り${remaining}体 うち特訓行き${transferredCount}体）`;
                    } else {
                        countText = `（残り${remaining}体）`;
                    }
                }
                
                // リセットボタン表示条件: 誰か倒している or 特訓に送っている
                if (clearedCount > 0 || transferredCount > 0) {
                    showReset = true;
                }
            }
            
            nameSpan.textContent = label + " " + countText;
            li.appendChild(nameSpan);

            // リセットボタンの追加
            if (showReset) {
                const resetBtn = document.createElement('button');
                resetBtn.className = 'reset-btn';
                resetBtn.textContent = 'リセット';
                resetBtn.onclick = (e) => {
                    e.stopPropagation(); // 親のliのクリックイベントを防止
                    if (confirm(`${map.name}のデータをリセットしますか？`)) {
                        if (map.id === 7) {
                            resetTrainingRoom();
                        } else {
                            resetMapData(map.id);
                        }
                    }
                };
                li.appendChild(resetBtn);
            }
            
            if (index === titleCursorIndex) li.classList.add('selected');

            li.onclick = () => {
                startGame(index);
            };
            
            li.onmouseover = () => {
                updateTitleCursor(index);
            };

            levelList.appendChild(li);
        });

        // 「すべての記録を削除する」ボタン
        const deleteLi = document.createElement('li');
        deleteLi.className = 'level-item';
        
        const deleteSpan = document.createElement('span');
        deleteSpan.textContent = "【すべての戦績を削除する】";
        deleteSpan.style.color = "#ff6666";
        deleteLi.appendChild(deleteSpan);
        
        if (titleCursorIndex === MAP_DATA.length) {
            deleteLi.classList.add('selected');
        }

        deleteLi.onclick = () => {
            confirmDeleteAllData();
        };

        deleteLi.onmouseover = () => {
            updateTitleCursor(MAP_DATA.length);
        };

        levelList.appendChild(deleteLi);
    }

    function updateTitleCursor(index) {
        const items = levelList.getElementsByClassName('level-item');
        if (index >= 0 && index < items.length) {
            if (items[titleCursorIndex]) {
                items[titleCursorIndex].classList.remove('selected');
            }
            titleCursorIndex = index;
            items[titleCursorIndex].classList.add('selected');
            items[titleCursorIndex].scrollIntoView({ block: 'nearest' });
        }
    }

    function startGame(mapId) {
        if (mapId < 0 || mapId >= MAP_DATA.length) return;

        titleScreen.style.display = 'none';
        menuBtn.style.display = 'block';
        gameStarted = true;
        
        currentMapId = mapId;
        currentMap = MAP_DATA[currentMapId];
        
        // NPC生成ロジック
        currentMap.entities = [];
        
        if (currentMapId === 7) {
            // 特訓会場の場合：storageから生成
            generateTrainingNPCs();
        } else {
            // 通常マップの場合：CSVデータから生成
            generateNormalMapNPCs(currentMapId);
        }

        entities = currentMap.entities;
        player.x = currentMap.playerStart.x;
        player.y = currentMap.playerStart.y;
        player.direction = 'down';
        currentState = STATE.EXPLORING;
        
        // メッセージ表示は削除しました
    }

    function generateNormalMapNPCs(mapId) {
        const npcsData = originalNPCsByMap[mapId] || [];
        const progressObj = savedProgress[mapId] || { cleared: [], transferred: [] };

        npcsData.forEach((npcData, index) => {
            // 正答済み、または特訓行きのNPCは表示しない
            if (progressObj.cleared.includes(index) || progressObj.transferred.includes(index)) return;

            const color = NPC_COLORS[npcData.sprite.toLowerCase()] || '#9e9e9e';
            const sprite = { color: color, type: 'villager' };
            const options = npcData.option.split(';').map(o => o.trim());
            const pos = findRandomWalkablePosition(currentMap);
            
            if (pos) {
                currentMap.entities.push({
                    originalIndex: index, // マップ内通し番号
                    mapId: mapId,
                    x: pos.x,
                    y: pos.y,
                    sprite: sprite,
                    blocking: true,
                    blinking: false,
                    quiz: {
                        question: npcData.question,
                        options: options,
                        correct: npcData.correct,
                        hint: npcData.hint
                    }
                });
            }
        });
    }

    function generateTrainingNPCs() {
        savedTrainingData.forEach((data) => {
            const color = NPC_COLORS[data.sprite.toLowerCase()] || '#9e9e9e';
            const sprite = { color: color, type: 'villager' };
            const pos = findRandomWalkablePosition(currentMap);
            
            if (pos) {
                // ステータスが不正解なら点滅状態で表示
                const isCorrect = (data.status === 'correct');
                
                currentMap.entities.push({
                    // 特訓会場では元のID情報を保持する
                    sourceMapId: data.sourceMapId,
                    sourceIndex: data.sourceIndex,
                    
                    x: pos.x,
                    y: pos.y,
                    sprite: sprite,
                    blocking: true,
                    blinking: !isCorrect, // 不正解（初期状態）なら点滅
                    quiz: {
                        question: data.question,
                        options: data.options,
                        correct: data.correct,
                        hint: data.hint
                    }
                });
            }
        });
    }

    function findRandomWalkablePosition(map) {
        const layout = map.layout;
        const playerStart = map.playerStart;
        const maxAttempts = 1000;
        
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const x = Math.floor(Math.random() * layout[0].length);
            const y = Math.floor(Math.random() * layout.length);
            
            const tile = layout[y][x];
            // 0:Grass, 3:Floor, 9:StartPos (Treat as floor)
            if (tile !== 0 && tile !== 3 && tile !== 9) continue;
            
            // プレイヤー初期位置付近は避ける
            const dist = Math.abs(x - playerStart.x) + Math.abs(y - playerStart.y);
            if (dist < 2) continue;
            
            const overlap = map.entities.some(e => e.x === x && e.y === y);
            if (overlap) continue;
            
            return { x, y };
        }
        return null;
    }

    function resize() {
        const container = document.getElementById('game-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        ctx.imageSmoothingEnabled = false;
    }
    window.addEventListener('resize', resize);
    resize();

    const keys = {};
    let lastKeyTime = 0;
    const keyRepeatRate = 150;

    // メニューボタンイベント
    menuBtn.addEventListener('click', () => {
        // 問いかけなしでタイトル画面へ戻る
        showTitleScreen();
    });

    messageOkBtn.addEventListener('click', () => {
        if (currentState === STATE.DIALOGUE) {
            progressDialogue();
        }
    });

    // クイズウィンドウのボタンイベント
    quizOkBtn.addEventListener('click', () => {
        if (currentState === STATE.CHOICE && currentChoiceIndex !== -1) {
            confirmChoice();
        } else if (currentState === STATE.HINT) {
            returnToQuizFromHint();
        }
    });

    // 特訓行きボタン
    quizTransferBtn.addEventListener('click', () => {
        if (currentState === STATE.CHOICE) {
            transferCurrentNPC();
        }
    });

    // 元のフロアに戻すボタン
    quizReturnBtn.addEventListener('click', () => {
        if (currentState === STATE.CHOICE) {
            returnCurrentNPC();
        }
    });

    window.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        handleInput(e.code);
    });
    window.addEventListener('keyup', (e) => {
        keys[e.code] = false;
    });

    document.querySelectorAll('[data-key]').forEach(el => {
        el.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const key = el.getAttribute('data-key');
            keys[key] = true;
            handleInput(key);
        }, {passive: false});

        el.addEventListener('touchend', (e) => {
            e.preventDefault();
            const key = el.getAttribute('data-key');
            keys[key] = false;
        });
        
        el.addEventListener('mousedown', (e) => {
            const key = el.getAttribute('data-key');
            keys[key] = true;
            handleInput(key);
        });
        el.addEventListener('mouseup', (e) => {
            const key = el.getAttribute('data-key');
            keys[key] = false;
        });
    });

    function handleInput(code) {
        if (STATE.TITLE === currentState) {
            handleTitleInput(code);
        } else if (STATE.EXPLORING === currentState) {
            // 探索中の操作
        } else if (STATE.DIALOGUE === currentState) {
            handleDialogueInput(code);
        } else if (STATE.CHOICE === currentState) {
            handleChoiceInput(code);
        } else if (STATE.HINT === currentState) {
            handleHintInput(code);
        }
    }

    function handleTitleInput(code) {
        const maxIndex = levelList.childElementCount - 1;

        if (code === 'ArrowUp') {
            updateTitleCursor(Math.max(0, titleCursorIndex - 1));
        } else if (code === 'ArrowDown') {
            updateTitleCursor(Math.min(maxIndex, titleCursorIndex + 1));
        } else if (code === 'Enter' || code === 'Space' || code === 'KeyZ') {
            if (titleCursorIndex === MAP_DATA.length) {
                confirmDeleteAllData();
            } else {
                startGame(titleCursorIndex);
            }
        }
    }

    function handleDialogueInput(code) {
        if (code === 'Enter' || code === 'Space' || code === 'KeyZ') {
            progressDialogue();
        }
    }

    function handleHintInput(code) {
        const scrollAmount = 30;
        if (code === 'ArrowUp') {
            quizQuestion.scrollTop -= scrollAmount;
        } else if (code === 'ArrowDown') {
            quizQuestion.scrollTop += scrollAmount;
        } else if (code === 'Enter' || code === 'Space' || code === 'KeyZ') {
            returnToQuizFromHint();
        }
    }

    function progressDialogue() {
        if (isWaitingForEnter) {
            if (textCallback) {
                const cb = textCallback;
                textCallback = null;
                cb();
            } else {
                closeDialogue();
            }
        } else {
            if (textAnimationTimer) {
                clearInterval(textAnimationTimer);
                messageText.innerHTML = fullText.replace(/\n/g, '<br>');
                isWaitingForEnter = true;
                messageCursor.style.display = 'inline-block';
                messageOkBtn.style.display = 'block';
            }
        }
    }

    function handleChoiceInput(code) {
        const hasHint = currentQuizData.hint && currentQuizData.hint.trim() !== "";
        const totalOptions = currentQuizData.options.length + (hasHint && !systemChoiceCallback ? 1 : 0);

        if (code === 'ArrowUp') {
            if (currentChoiceIndex === -1) {
                currentChoiceIndex = totalOptions - 1;
            } else {
                currentChoiceIndex = Math.max(0, currentChoiceIndex - 1);
            }
            renderChoices();
        } else if (code === 'ArrowDown') {
            if (currentChoiceIndex === -1) {
                currentChoiceIndex = 0;
            } else {
                currentChoiceIndex = Math.min(totalOptions - 1, currentChoiceIndex + 1);
            }
            renderChoices();
        } 
        else if (code === 'Enter' || code === 'Space' || code === 'KeyZ') {
            if (currentChoiceIndex !== -1) {
                confirmChoice();
            }
        }
    }

    function isWalkable(x, y) {
        const mapLayout = currentMap.layout;
        if (y < 0 || y >= mapLayout.length || x < 0 || x >= mapLayout[0].length) return false;
        
        const tile = mapLayout[y][x];
        if (tile === 1 || tile === 2 || tile === 4) return false;

        for (let e of entities) {
            if (e.x === x && e.y === y && e.blocking && !e.removed) return false;
        }
        
        return true;
    }

    function update() {
        if (currentState === STATE.EXPLORING) {
            movePlayer();
            checkAutoInteraction();
        }
    }

    function movePlayer() {
        const now = Date.now();
        if (now - lastKeyTime < keyRepeatRate) return;

        let dx = 0;
        let dy = 0;
        let moved = false;

        if (keys['ArrowUp']) { dy = -1; player.direction = 'up'; moved = true; }
        else if (keys['ArrowDown']) { dy = 1; player.direction = 'down'; moved = true; }
        else if (keys['ArrowLeft']) { dx = -1; player.direction = 'left'; moved = true; }
        else if (keys['ArrowRight']) { dx = 1; player.direction = 'right'; moved = true; }

        if (moved) {
            const newX = player.x + dx;
            const newY = player.y + dy;

            if (isWalkable(newX, newY)) {
                player.x = newX;
                player.y = newY;
                player.stepState = (player.stepState + 1) % 2;
            }
            lastKeyTime = now;
        }
    }

    function checkAutoInteraction() {
        const directions = [
            {dx: 0, dy: -1}, {dx: 0, dy: 1},
            {dx: -1, dy: 0}, {dx: 1, dy: 0},
            {dx: -1, dy: -1}, {dx: 1, dy: -1},
            {dx: -1, dy: 1}, {dx: 1, dy: 1}
        ];

        for (let dir of directions) {
            const targetX = player.x + dir.dx;
            const targetY = player.y + dir.dy;
            
            const targetEntity = entities.find(e => 
                e.x === targetX && 
                e.y === targetY && 
                !e.removed && 
                e.quiz && 
                !e.quizCompleted
            );

            if (targetEntity) {
                startQuiz(targetEntity);
                return;
            }
        }
    }

    function displayText(text, callback = null) {
        currentState = STATE.DIALOGUE;
        messageWindow.style.display = 'block';
        messageText.innerHTML = '';
        messageCursor.style.display = 'none';
        messageOkBtn.style.display = 'none';
        
        fullText = text;
        textCallback = callback;
        isWaitingForEnter = false;

        let i = 0;
        if (textAnimationTimer) clearInterval(textAnimationTimer);

        textAnimationTimer = setInterval(() => {
            messageText.innerHTML = fullText.substring(0, i + 1).replace(/\n/g, '<br>');
            i++;
            if (i >= fullText.length) {
                clearInterval(textAnimationTimer);
                isWaitingForEnter = true;
                messageCursor.style.display = 'inline-block';
                messageOkBtn.style.display = 'block';
            }
        }, 30);
    }

    function closeDialogue() {
        messageWindow.style.display = 'none';
        messageOkBtn.style.display = 'none';
        quizWindow.style.display = 'none';
        quizOkBtn.style.display = 'none';
        quizTransferBtn.style.display = 'none';
        quizReturnBtn.style.display = 'none';
        currentState = STATE.EXPLORING;
        textCallback = null;
    }

    function pushPlayerBack() {
        let dx = 0, dy = 0;
        if (player.direction === 'up') dy = 1;
        if (player.direction === 'down') dy = -1;
        if (player.direction === 'left') dx = 1;
        if (player.direction === 'right') dx = -1;

        if (isWalkable(player.x + dx, player.y + dy)) {
            player.x += dx;
            player.y += dy;
        }
        closeDialogue();
    }

    function startQuiz(entity) {
        currentState = STATE.CHOICE;
        currentQuizData = entity.quiz;
        currentQuizEntity = entity;
        currentChoiceIndex = 0;
        systemChoiceCallback = null; 

        quizWindow.style.display = 'flex';
        quizQuestion.innerHTML = currentQuizData.question.replace(/\n/g, '<br>');
        quizQuestion.scrollTop = 0;
        renderChoices();
        
        quizOkBtn.style.display = 'block';

        // 転送/戻すボタンの表示制御
        if (currentMapId === 7) {
            // 特訓会場
            quizTransferBtn.style.display = 'none';
            quizReturnBtn.style.display = 'block';
        } else {
            // 通常マップ
            quizTransferBtn.style.display = 'block';
            quizReturnBtn.style.display = 'none';
        }
    }

    // NPC転送処理（通常マップ -> 特訓会場）
    function transferCurrentNPC() {
        if (!currentQuizEntity) return;

        // 1. 通常マップの特訓行きリストに追加
        saveTransferredProgress(currentMapId, currentQuizEntity.originalIndex);

        // 2. トレーニングデータに追加
        const originalData = originalNPCsByMap[currentMapId][currentQuizEntity.originalIndex];

        savedTrainingData.push({
            sourceMapId: currentMapId,
            sourceIndex: currentQuizEntity.originalIndex,
            sprite: originalData.sprite,
            question: originalData.question,
            options: originalData.option.split(';').map(o=>o.trim()),
            correct: originalData.correct,
            hint: originalData.hint,
            status: 'incorrect' // 初期状態は不正解
        });
        saveTrainingDataToStorage();

        closeQuizWindow();
        
        // 点滅後消滅
        blinkAndRemoveNPC(currentQuizEntity, null);
    }

    // NPC戻す処理（特訓会場 -> 通常マップ）
    function returnCurrentNPC() {
        if (!currentQuizEntity) return;

        // 1. トレーニングデータから削除 & 元のマップのリストから削除
        removeNPCFromTraining(currentQuizEntity.sourceMapId, currentQuizEntity.sourceIndex);

        closeQuizWindow();

        // 点滅後消滅
        blinkAndRemoveNPC(currentQuizEntity, null);
    }

    function renderChoices() {
        quizChoices.innerHTML = '';
        
        const hasHint = currentQuizData.hint && currentQuizData.hint.trim() !== "";
        const showHintBtn = hasHint && !systemChoiceCallback;
        
        // 選択肢の生成
        currentQuizData.options.forEach((opt, index) => {
            const li = document.createElement('li');
            li.className = 'choice-item ' + (index === currentChoiceIndex ? 'selected' : '');
            li.textContent = opt;
            
            li.onclick = () => {
                currentChoiceIndex = index; 
                renderChoices(); 
                confirmChoice();
            };
            
            li.onmouseover = () => {
                if (currentState === STATE.CHOICE) {
                    currentChoiceIndex = index;
                    renderChoices(); 
                }
            }

            quizChoices.appendChild(li);
        });

        // 「解説を見る」ボタンの生成
        if (showHintBtn) {
            const hintIndex = currentQuizData.options.length;
            const li = document.createElement('li');
            li.className = 'choice-item hint-btn ' + (hintIndex === currentChoiceIndex ? 'selected' : '');
            li.textContent = '解説を見る';

            li.onclick = () => {
                currentChoiceIndex = hintIndex;
                renderChoices();
                confirmChoice();
            };

            li.onmouseover = () => {
                if (currentState === STATE.CHOICE) {
                    currentChoiceIndex = hintIndex;
                    renderChoices();
                }
            }
            quizChoices.appendChild(li);
        }

        // スクロール位置の自動調整
        if (currentChoiceIndex >= 0 && currentChoiceIndex < quizChoices.children.length) {
            const selectedElement = quizChoices.children[currentChoiceIndex];
            selectedElement.scrollIntoView({ block: 'nearest', behavior: 'auto' });
        }
    }
    
    function confirmChoice() {
        if (currentChoiceIndex === -1) return;

        const hasHint = currentQuizData.hint && currentQuizData.hint.trim() !== "";
        const showHintBtn = hasHint && !systemChoiceCallback;
        const isHintSelected = showHintBtn && (currentChoiceIndex === currentQuizData.options.length);

        if (isHintSelected) {
            showHint();
            return;
        }

        const selectedIndex = currentChoiceIndex;
        
        // 通常のクイズ判定
        if (selectedIndex === currentQuizData.correct) {
            handleCorrectAnswer();
        } else {
            handleIncorrectAnswer();
        }
    }

    function handleCorrectAnswer() {
        closeQuizWindow();

        if (currentMapId === 7) {
            // --- 特訓会場での正解 ---
            // 1. 点滅しなくなる
            currentQuizEntity.blinking = false;
            
            // 2. localStorageのステータスを更新
            const target = savedTrainingData.find(d => 
                d.sourceMapId === currentQuizEntity.sourceMapId && 
                d.sourceIndex === currentQuizEntity.sourceIndex
            );
            if (target) {
                target.status = 'correct';
                saveTrainingDataToStorage();
            }

            // 3. 正解メッセージの後、プレイヤーが離れる動き（不正解時と同様）
            displayText("「正解です!」", () => {
                pushPlayerBack();
            });

        } else {
            // --- 通常マップでの正解 ---
            currentQuizEntity.quizCompleted = true;
            
            // 1. 記録
            saveClearedProgress(currentMapId, currentQuizEntity.originalIndex);

            // 2. 点滅後、姿を消す
            blinkAndRemoveNPC(currentQuizEntity, () => {
                checkMapClear();
            });
        }
    }

    function handleIncorrectAnswer() {
        closeQuizWindow();

        // 特訓会場の場合は不正解ステータスに戻す
        if (currentMapId === 7) {
            currentQuizEntity.blinking = true;
            
            const target = savedTrainingData.find(d => 
                d.sourceMapId === currentQuizEntity.sourceMapId && 
                d.sourceIndex === currentQuizEntity.sourceIndex
            );
            if (target) {
                target.status = 'incorrect';
                saveTrainingDataToStorage();
            }
        }

        displayText("「違うな。出直してこい!」", () => {
            pushPlayerBack();
        });
    }

    function closeQuizWindow() {
        currentChoiceIndex = -1;
        quizWindow.style.display = 'none';
        quizOkBtn.style.display = 'none';
        quizTransferBtn.style.display = 'none';
        quizReturnBtn.style.display = 'none';
    }

    function showHint() {
        currentState = STATE.HINT;
        quizChoices.innerHTML = ''; 
        quizQuestion.innerHTML = `【解説】<br>${currentQuizData.hint.replace(/\n/g, '<br>')}`;
        quizQuestion.scrollTop = 0; 
        quizOkBtn.style.display = 'block';
        quizTransferBtn.style.display = 'none';
        quizReturnBtn.style.display = 'none';
    }

    function returnToQuizFromHint() {
        currentState = STATE.CHOICE;
        quizQuestion.innerHTML = currentQuizData.question.replace(/\n/g, '<br>');
        quizQuestion.scrollTop = 0;
        renderChoices();
        
        quizOkBtn.style.display = 'block';
        if (currentMapId === 7) {
            quizReturnBtn.style.display = 'block';
        } else {
            quizTransferBtn.style.display = 'block';
        }
    }

    function blinkAndRemoveNPC(npc, callback) {
        let blinkCount = 0;
        const maxBlinks = 6;
        
        const blinkInterval = setInterval(() => {
            npc.blinking = !npc.blinking; // 点滅トグル
            blinkCount++;
            
            if (blinkCount >= maxBlinks) {
                clearInterval(blinkInterval);
                npc.removed = true;
                npc.blocking = false;
                if (callback) callback();
            }
        }, 150);
    }

    function checkMapClear() {
        // 通常マップの場合のみクリア判定（特訓会場はクリア概念がない）
        if (currentMapId === 7) {
            closeDialogue();
            return;
        }

        const allCompleted = entities.every(e => !e.quiz || e.quizCompleted || e.removed);
        
        if (allCompleted) {
            createConfetti();
            displayText(`このフロアをクリアした!\nメニューに戻ります。`, () => {
                closeDialogue();
                setTimeout(() => {
                    showTitleScreen();
                }, 500);
            });
        } else {
            closeDialogue();
        }
    }

    function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const scale = canvas.width / (VIEW_WIDTH * TILE_SIZE);
        
        ctx.save();
        ctx.scale(scale, scale);

        const camX = player.x * TILE_SIZE - (VIEW_WIDTH * TILE_SIZE) / 2 + TILE_SIZE / 2;
        const camY = player.y * TILE_SIZE - (VIEW_HEIGHT * TILE_SIZE) / 2 + TILE_SIZE / 2;

        ctx.translate(-camX, -camY);

        const mapLayout = currentMap.layout;
        for (let y = 0; y < mapLayout.length; y++) {
            for (let x = 0; x < mapLayout[y].length; x++) {
                drawTile(x, y, mapLayout[y][x]);
            }
        }

        entities.forEach(ent => {
            if (ent.removed) return;

            // blinkingプロパティがtrueの場合は点滅させる（描画したりしなかったり）
            if (ent.blinking) {
                if (Math.random() > 0.5) {
                    drawSprite(ent.x, ent.y, ent.sprite);
                }
            } else {
                drawSprite(ent.x, ent.y, ent.sprite);
            }
        });

        // プレイヤー描画
        drawSprite(player.x, player.y, SPRITE_HERO, true);

        ctx.restore();

        if (confettiParticles.length > 0) {
            updateAndDrawConfetti();
        }

        requestAnimationFrame(draw);
    }

    function drawTile(x, y, type) {
        const px = x * TILE_SIZE;
        const py = y * TILE_SIZE;

        let color = '#000';
        switch (type) {
            case 0: color = COLOR_GRASS; break;
            case 1: color = COLOR_TREE; break;
            case 2: color = COLOR_WATER; break;
            case 3: 
            case 9: color = COLOR_FLOOR; break;
            case 4: color = COLOR_WALL; break;
        }

        ctx.fillStyle = color;
        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

        if (type === 1) {
            ctx.fillStyle = '#2e7d32';
            ctx.fillRect(px + 8, py + 8, 16, 16);
        } else if (type === 4) {
            ctx.strokeStyle = '#5d4037';
            ctx.strokeRect(px+2, py+2, TILE_SIZE-4, TILE_SIZE-4);
        } else if (type === 2) {
            if (Date.now() % 1000 < 500) {
                ctx.fillStyle = '#4fc3f7';
                ctx.fillRect(px + 5, py + 5, 5, 2);
            }
        }
    }

    function drawSprite(gridX, gridY, sprite, isPlayer = false) {
        const px = gridX * TILE_SIZE;
        const py = gridY * TILE_SIZE;

        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(px + 16, py + 26, 10, 4, 0, 0, Math.PI * 2);
        ctx.fill();

        let offset = 0;
        if (isPlayer && currentState === STATE.EXPLORING && (keys['ArrowUp'] || keys['ArrowDown'] || keys['ArrowLeft'] || keys['ArrowRight'])) {
             offset = (Date.now() % 200 < 100) ? -2 : 0;
        }

        ctx.fillStyle = sprite.color;
        ctx.fillRect(px + 8, py + 4 + offset, 16, 14);
        
        ctx.fillStyle = '#000';
        ctx.fillRect(px + 8, py + 18 + offset, 6, 8);
        ctx.fillRect(px + 18, py + 18 + offset, 6, 8);
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(px + 10, py + 8 + offset, 4, 4);
        ctx.fillRect(px + 18, py + 8 + offset, 4, 4);
        ctx.fillStyle = '#000';
        
        if (isPlayer) {
             let eyeOffsetX = 1;
             if (player.direction === 'left') eyeOffsetX = 0;
             if (player.direction === 'right') eyeOffsetX = 2;
             
             ctx.fillRect(px + 10 + eyeOffsetX, py + 9 + offset, 2, 2);
             ctx.fillRect(px + 18 + eyeOffsetX, py + 9 + offset, 2, 2);
        } else {
             ctx.fillRect(px + 11, py + 9 + offset, 2, 2);
             ctx.fillRect(px + 19, py + 9 + offset, 2, 2);
        }
    }

    function createConfetti() {
        confettiParticles = [];
        
        for(let i = 0; i < 50; i++) {
            confettiParticles.push({
                x: Math.random() * canvas.width,
                y: -20 - Math.random() * 100,
                vx: (Math.random() - 0.5) * 2,
                vy: Math.random() * 2 + 1,
                size: Math.random() * 8 + 3,
                color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.2
            });
        }
    }

    function updateAndDrawConfetti() {
        for (let i = confettiParticles.length - 1; i >= 0; i--) {
            const p = confettiParticles[i];
            
            p.x += p.vx;
            p.y += p.vy;
            p.rotation += p.rotationSpeed;
            
            if (p.y > canvas.height + 20) {
                confettiParticles.splice(i, 1);
                continue;
            }
            
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation);
            ctx.fillStyle = p.color;
            ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
            ctx.restore();
        }
    }

    setInterval(update, 1000 / 60);
    requestAnimationFrame(draw);

</script>
</body>
</html>